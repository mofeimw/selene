#+title: selene: greek goddess of the moon
#+author: mofei
** shell script
#+begin_src shell :tangle ~/selene.sh :tangle-mode (identity #o755)
#!/bin/sh
#
if [ "$1" = "launcher" ]; then
    if [ $(ps aux | grep -v grep | grep -ci "emacsclient") -eq 0 ]; then
        emacsclient -c
    fi
    emacsclient -e  "(select-frame-set-input-focus (selected-frame))"
    exit
elif [ "$1" = "diff" ]; then
    diff ~/selene.org ~/selene/selene.org
    exit
elif [ "$1" = "tangle" ]; then
    emacsclient -e '(org-babel-tangle-file "~/selene.org")'
    exit
elif [ "$1" = "kill" ]; then
    emacsclient -e "(kill-emacs)"
    exit
elif [ "$1" = "restart" ]; then
    emacsclient -e "(kill-emacs)"
elif [ "$1" = "retangle" ]; then
    emacsclient -e '(org-babel-tangle-file "~/selene.org")'
    emacsclient -e "(kill-emacs)"
fi

emacs --daemon
#+end_src

** helios
#+begin_src emacs-lisp :tangle ~/helios.el
;;; require packages
(require 'calendar)

(define-derived-mode nyx-mode fundamental-mode "nyx"
  "major mode for editing .nyx files"
  ;; remove pesky autoindented tab after newlines
  (setq-local indent-line-function 'ignore))
(add-to-list 'auto-mode-alist '("\\.nyx\\'" . nyx-mode))

(define-minor-mode helios-mode
  "minor mode for helios buffers"
  :lighter "helios"
  :global nil
  ;; toggle mixed pitch mode and cursor color
  (if helios-mode
      (progn
        (mixed-pitch-mode 1)
        (setq-local evil-normal-state-cursor "#18131B"))
    (progn
      (mixed-pitch-mode -1)
      (setq-local evil-normal-state-cursor '("#b4f9f8" box)))))

;;; define helios fonts
(defface helios/font/h1
  '((t (:foreground "#e0af68" :height 600 :family "Egmond")))
  "helios header 1 font")
(defface helios/font/h2
  '((t (:foreground "#b4f9f8" :weight bold :height 210)))
  "helios header 2 font")
(defface helios/font/h4
  '((t (:foreground "#bb9af7" :weight bold :height 200)))
  "helios header 4 font")
(defface helios/font/quote
  '((t (:foreground "#bb9af7" :slant italic :height 222 :family "Yrsa")))
  "helios quote font")
(defface helios/font/code
  '((t (:foreground "#7aa2f7" :height 150 :family "Fira Code")))
  "helios monospace/code font")
(defface helios/font/exclamation
  '((t (:foreground "#f7768e")))
  "helios ! font")
(defface helios/font/thread-highlight
  '((t (:foreground "#b4f9f8" :weight bold)))
  "helios thread highlight font")
(defface helios/font/command-highlight
  '((t (:foreground "#bb9af7" :weight bold)))
  "helios command highlight font")
(defface helios/font/chunk-description
  '((t (:foreground "#7aa2f7" :weight bold)))
  "helios chunk description font")
(defface helios/font/chunk-recall
  '((t (:foreground "#e0af68" :weight bold)))
  "helios chunk recall font")
(defface helios/font/emphasis
  '((t (:foreground "#b4f9f8")))
  "helios emphasis font")
(defface helios/font/inactive
  '((t (:foreground "#8b7694")))
  "helios inactive font")

;;; define helios variables
(defvar helios/threads '())
(defvar helios/threadkeys '())
(defvar helios/countdown '())
(defvar helios/todo '())

(defvar helios/parser/chunk-open nil)
(defvar helios/parser/chunk-thread nil)
(defvar helios/parser/chunk-temp '())
(defvar helios/parser/recall-date nil)
(defvar helios/parser/suppress nil)

(defvar helios/todo/active 0)

(defun helios/load-file ()
  "load helios.nyx"
  ;; reset variables
  (setq helios/threads '())
  (setq helios/threadkeys '())
  (setq helios/countdown '())
  (setq helios/todo '())

  (setq helios/parser/chunk-open nil)
  (setq helios/parser/chunk-thread nil)
  (setq helios/parser/chunk-temp '())
  (setq helios/parser/recall-date nil)
  (setq helios/parser/suppress nil)

  (setq helios/todo/active 0)

  ;; insert contents into a temporary buffer
  (with-temp-buffer
    (insert-file-contents "~/helios.nyx")
    (goto-char (point-min))
    ;; read line by line
    (while (not (eobp))
      (let ((line (buffer-substring-no-properties
                   (line-beginning-position)
                   (line-end-position))))
        ;; parse each line
        (helios/parser line)
        (forward-line 1)))))

(defun helios/parser (line)
  "helios parser"
  ;; don't suppress append by default
  (setq helios/parser/suppress nil)
  ;; group chunks together in temporary list
  (when (and (not (equal line "~")) helios/parser/chunk-open)
    (setq helios/parser/suppress t)
    (push line helios/parser/chunk-temp))

  (cond
   ;; parse closing chunk or plain opening chunk
   ((string-match "^~$" line)
    (setq helios/parser/suppress t)
    (if helios/parser/chunk-open
        ;; closing chunk if flag was open
        (progn
          ;; add to main thread
          (let ((main-thread (assoc "main" helios/threads)))
            (if main-thread
                (setcdr main-thread (cons helios/parser/chunk-temp (cdr main-thread)))
              (push (list "main" helios/parser/chunk-temp) helios/threads)))

          ;; add to recall thread if recall
          (if helios/parser/recall-date
              (let ((thread-list (assoc "recall" helios/threads)))
                (if thread-list
                    (setcdr thread-list (cons helios/parser/chunk-temp (cdr thread-list)))
                  (push (list "recall" helios/parser/chunk-temp) helios/threads))))

          ;; add to thread if tagged
          (if helios/parser/chunk-thread
              (let ((thread-list (assoc helios/parser/chunk-thread helios/threads)))
                (if thread-list
                    (setcdr thread-list (cons helios/parser/chunk-temp (cdr thread-list)))
                  (push (list helios/parser/chunk-thread helios/parser/chunk-temp) helios/threads))))

          ;; reset for next chunk
          (setq helios/parser/chunk-open nil)
          (setq helios/parser/chunk-temp '())
          (setq helios/parser/chunk-thread nil)
          (setq helios/parser/recall-date nil))

      ;; opening chunk if flag was closed
      (progn
        ;; set chunk flag to open
        (setq helios/parser/chunk-open t)
        ;; empty description because plain
        (push "" helios/parser/chunk-temp))))

   ;; parse opening chunk with optional description
   ((string-match "^~\s*\\([@./'# a-zA-Z0-9]*\\)$" line)
    (setq helios/parser/suppress t)
    ;; extract description
    (let ((description (match-string 1 line)))
      (push description helios/parser/chunk-temp)

      ;; is a daily recall
      (if (string-match "^@\\([0-9]+\\([/.]\\)[0-9]+\\(?:\\2[0-9]+\\)?\\).*" description)
          (setq helios/parser/recall-date (match-string 1 description)))

      ;; extract thread if found
      (if (string-match ".*#\\([a-zA-Z0-9_-]+\\).*" description)
          (setq helios/parser/chunk-thread (match-string 1 description))))
    ;; declare open chunk or error if previous chunk was not closed
    (if helios/parser/chunk-open
        (message "[helios] invalid syntax: chunk not closed")
      (setq helios/parser/chunk-open t)))

   ;; parse thread tags
   ((string-match "^.*#\\([a-zA-Z0-9_-]+\\).*$" line)
    ;; pull out name of thread and grab its nested list
    (let* ((thread (match-string 1 line))
           (thread-list (assoc thread helios/threads)))
      ;; append to nested thread list
      (if thread-list
          (setcdr thread-list (cons line (cdr thread-list)))
        ;; or make a new nested list if not already existing
        (push (list thread line) helios/threads))))

   ;; parse commands
   ((string-match "^.*#{\\([a-zA-Z0-9_-]+\\)}.*$" line)
    ;; pull out name of command
    (let* ((command (match-string 1 line))
           ;; grab symbol of command function
           (command-function (intern (concat "helios/command/" command)))
           ;; remove command tag from line, considering remaining as arguments
           (args (replace-regexp-in-string "#{.*}" "" line)))
      ;; check if command function is bound and call with arguments or log warning
      (if (fboundp command-function)
          (funcall command-function args)
        (message "[helios] command not found: %s" command)))))

  ;; append all nonempty lines to main thread, if not suppressed
  (unless (or (string= line "") helios/parser/suppress)
    (let ((main-thread (assoc "main" helios/threads)))
      (if main-thread
          (setcdr main-thread (cons line (cdr main-thread)))
        ;; create main thread if not already existing
        (push (list "main" line) helios/threads)))))

(defun helios/command/countdown (args)
  "helios countdown command"
  (cond
   ;; disable countdown if arguments are "off" or empty
   ((or (string= args "") (string= args "off"))
    (setq helios/countdown '()))

   ;; parse arguments if matching format: date first, separated by . or /, then optional description in brackets
   ((string-match "\\([0-9]+\\([/.]\\)[0-9]+\\(?:\\2[0-9]+\\)?\\)\\s-*\\(?:\\[\\(.*?\\)\\]\\)?\\s-*$" args)
    ;; pull out date, separator, description (defaulting to "")
    (let* ((date-string (match-string 1 args))
           (separator (match-string 2 args))
           (description (or (match-string 3 args) ""))
           ;; get today's date, parse date string, then calculate number of days between
           (today (calendar-current-date))
           (date (helios/parse-date date-string separator))
           (days-between (- (calendar-absolute-from-gregorian date)
                            (calendar-absolute-from-gregorian today))))
      ;; set countdown variable to cons cell of description and number of days between
      (setq helios/countdown (cons description days-between))))

   ;; invalid syntax - log warning
   (t
    (message "[helios|countdown] invalid syntax: %s" args))))

(defun helios/parse-date (date-string separator)
  "parse date string"
  ;; split date string by separator and convert to numbers
  (let* ((parts (mapcar #'string-to-number (split-string date-string (regexp-quote separator))))
         ;; pull out month and day
         (month (nth 0 parts))
         (day (nth 1 parts))
         ;; pull out year, defaulting to current year if not provided
         (year (or (nth 2 parts) (nth 2 (calendar-current-date))))
         ;; reconstruct into date list
         (date (list month day year))
         ;; get today's date
         (today (calendar-current-date)))
    ;; turn YY year format into YYYY by just adding 2000 and update date list
    (when (< year 100)
      (setq year (+ 2000 year))
      (setq date (list month day year)))
    ;; check if year was provided
    (when (< (length parts) 3)
      ;; offset year to next year if date has already passed
      (if (< (calendar-absolute-from-gregorian date)
             (calendar-absolute-from-gregorian today))
          (setf (nth 2 date) (1+ year))))
    date))

(defun helios/command/todo (args)
  "helios todo command"
  ;; switch conditional cases cascade down
  (cond
   ;; [x] indicates marking todo as completed
   ((string-match "\\(.*?\\)\\s-*\\[x\\]\\s-*$" args)
    ;; pull out task and set found flag to false
    (let ((task (match-string 1 args))
          (found nil))
      ;; loop over all todos
      (dolist (item helios/todo)
        ;; set found flag to true and mark todo as completed when found
        ;; decrement to keep count of active uncompleted todos
        (when (string= task (car item))
          (setq found t)
          (setcdr item "x")
          (setq helios/todo/active (- helios/todo/active 1))))
      ;; log warning if todo was never found
      (unless found
        (message "[helios|todo] task not found: %s" task))))

   ;; parse arguments if matching syntax: task first, then optional date in brackets separated by . or /
   ((string-match "\\(.*?\\)\\s-*\\(?:\\[\\([0-9]+\\([/.]\\)[0-9]+\\(?:\\3[0-9]+\\)?\\)\\]\\)?\\s-*$" args)
    ;; pull out task, date, and separator
    (let* ((task (match-string 1 args))
           (date-string (or (match-string 2 args) ""))
           (separator (match-string 3 args)))
      ;; push cons cell of task and date string to todos
      (push (cons task date-string) helios/todo)
      ;; keep track of active todos
      (setq helios/todo/active (+ helios/todo/active 1))))

   ;; catchall indicates no valid syntax was matched
   ;; invalid syntax - log warning
   (t
    (message "[helios|todo] invalid syntax: %s" args))))

(defun helios/load-dashboard ()
  "load helios dashboard"
  ;; set left margin to 2/5 of window width
  (setq margin-left (* (/ (window-total-width) 5) 2))
  ;; responsive - if window width is less than 100, set margin to 1/3 of width
  (when (< (window-total-width) 100)
    (setq margin-left (/ (window-total-width) 3)))

  ;; define quote bank
  (setq quotes '(
                 "prime time grind time"
                 "cook or get cooked"
                 "pressure makes diamonds"
                 "I N V E R T"
                 "lock the fuck in"
                 "garbage in, garbage out"
                 "day by day but make each count"
                 "the only certainty in life is uncertainty"
                 "the time will pass anyways..."
                 "is this all a dream?"))
  ;; pick a random quote
  (setq quote (nth (random (length quotes)) quotes))

  ;; get or create helios buffer
  (with-current-buffer (helios/buffer)
    ;; inhibit read only in buffer
    (let ((inhibit-read-only t))
      ;; erase buffer and insert headline and random quote
      (erase-buffer)
      (insert "H E L I O S\n")
      (insert (format "\"%s\"\n" quote))

      ;; check that countdown is enabled
      (when helios/countdown
        (if (>= (cdr helios/countdown) 0)
            ;; insert formatted countdown depending on if description is provided
            (if (string-empty-p (car helios/countdown))
                (insert (format "<%d days remaining>\n" (cdr helios/countdown)))
              (insert (format "<%s: %d days remaining>\n" (car helios/countdown) (cdr helios/countdown))))))

      ;; insert heading if there are threads
      (if (> (length helios/threads) 0)
          (insert "threads\n"))
      (let ((count 0))
        (catch 'break
          ;; loop over threadkeys list
          (mapcar (lambda (pair)
                    ;; break to only show first 4 threads
                    (when (> count 3)
                      (throw 'break nil))
                    ;; insert word formatted to emphasize keybind
                    ;; split where first occurance of letter is and piece together
                    (let* ((word (car pair))
                           (letter (cdr pair))
                           (match (string-match (regexp-quote letter) word 0)))
                      (insert (substring word 0 (match-beginning 0)))
                      (insert (propertize letter 'font-lock-face 'helios/font/emphasis))
                      (insert (substring word (match-end 0)))
                      (insert "\n")
                      (setq count (+ count 1))))
                  helios/threadkeys))

      ;; insert heading if there are active todos
      (if (> helios/todo/active 0)
          (insert "todo\n"))
      ;; loop over todos
      (let ((count 0))
        (catch 'break
          (dolist (todo helios/todo)
            ;; break to only show first 4 todos
            (when (> count 3)
              (throw 'break nil))
            ;; insert todo bullet if active
            (unless (string= "x" (cdr todo))
              (setq count (+ count 1))
              ;; format depending on whether deadline is provided
              (if (string-empty-p (cdr todo))
                  (insert (format "• %s\n" (car todo)))
                (insert (format "• %s [%s]\n" (car todo) (cdr todo)))))))))))

  ;; switch to helios buffer and refresh buffer
  (switch-to-buffer (helios/buffer))
  (helios/buffer-hook)

  ;; set fonts
  (setq font-lock-defaults nil)
  (setq helios-dashboard-font-lock
        '(("H E L I O S"
           (0 'helios/font/h1 t))
          ("^\".+\"$"
           (0 'helios/font/quote t))
          ("^<.+>$"
           (0 'helios/font/code t))
          ("^\\<\\(threads\\|todo\\)\\>$"
           (0 'helios/font/h2 t))
          ("^.*!.*$"
           (0 'helios/font/exclamation t))))
  (setq font-lock-defaults '(helios-dashboard-font-lock))
  (setq-local line-spacing 18)
  (font-lock-mode 1)

  (helios/neutralize-mouse)

  ;; bind thread and todo expansion buffers
  (evil-local-set-key 'normal (kbd "1")
                      `(lambda ()
                         (interactive)
                         (funcall 'helios/spawn-buffer "threads" #'helios/threads-content)))
  (evil-local-set-key 'normal (kbd "2")
                      `(lambda ()
                         (interactive)
                         (funcall 'helios/spawn-buffer "todo" #'helios/todo-content)))

  ;; set margins, enable line wrapping, set read only and go to origin point
  (set-window-margins (selected-window) margin-left 8)
  (visual-line-mode t)
  (read-only-mode 1)
  (goto-char (point-min))

  ;; hook into buffer list update
  (add-hook 'buffer-list-update-hook #'helios/buffer-hook))

(defun helios/buffer ()
  "get or create helios buffer"
  (get-buffer-create "*helios*"))

(defun helios/buffer-hook ()
  "helios buffer hook"
  ;; check when current buffer is helios dashboard and use header/mode lines as top/bottom padding
  (when (string-equal (buffer-name) "*helios*")
    ;; empty header line, set background color to match background and jack up height
    (setq-local header-line-format '(" "))
    (custom-set-faces
     '(header-line ((t (:background "#18131B" :foreground "#18131B"))))
     '(header-line-inactive ((t (:background "#18131B" :foreground "#18131B")))))
    (face-remap-add-relative 'header-line '((:height 1300)))
    ;; empty mode line, set background color to match background and jack up height
    (setq-local mode-line-format '(" "))
    (custom-set-faces
     '(mode-line ((t (:background "#18131B" :foreground "#18131B"))))
     '(mode-line-inactive ((t (:background "#18131B" :foreground "#18131B")))))
    (face-remap-add-relative 'mode-line '((:height 1300))))

  ;; reset mode/header lines if current buffer isn't helios dashboard
  (unless (string-equal (buffer-name) "*helios*")
    (custom-set-faces
     '(mode-line ((t (:inherit mode-line))))
     '(mode-line-inactive ((t (:inherit mode-line-inactive))))
     '(header-line ((t nil)))))

  ;; enable helios minor mode in all helios buffers
  (if (string-match "^\*helios" (buffer-name))
      (helios-mode 1)
    (helios-mode -1)))

(defun helios/neutralize-mouse ()
  "neutralize mouse"
  (define-key evil-motion-state-local-map [down-mouse-1] #'ignore)
  (define-key evil-motion-state-local-map [mouse-1] #'ignore)
  (define-key evil-motion-state-local-map [drag-mouse-1] #'ignore)
  (define-key evil-motion-state-local-map [double-mouse-1] #'ignore)
  (define-key evil-motion-state-local-map [triple-mouse-1] #'ignore)
  (define-key evil-motion-state-local-map [mouse-2] #'ignore)
  (define-key evil-motion-state-local-map [mouse-3] #'ignore)
  (define-key evil-motion-state-local-map [wheel-up] #'ignore)
  (define-key evil-motion-state-local-map [wheel-down] #'ignore))

(defun helios/generate-thread-keys ()
  "find unique keys for threads"
  ;; use a hash table for efficiency
  (let ((used-letters (make-hash-table))
        result)
    ;; loop in reverse to maintain stability because threads are from most recent first
    (dolist (thread (reverse helios/threads))
      ;; loop over chracters to find when they are a letter and not already used
      ;; or if no options are available, pick the first available letter in alphabet
      (let* ((name (car thread))
             (unique-letter (or (cl-loop for char across name
                                         when (and (cl-position char "abcdefghijklmnopqrstuvwxyz")
                                                   (not (gethash (downcase char) used-letters)))
                                         return (downcase char))
                                (cl-loop for char across "abcdefghijklmnopqrstuvwxyz"
                                         unless (gethash char used-letters)
                                         return char))))
        ;; update hash table and results list
        (when unique-letter
          (puthash unique-letter t used-letters)
          ;; convert from char to string
          (push (cons name (string unique-letter)) result))))
    (setq helios/threadkeys result)))

(defun helios/generate-thread-binds ()
  "generate keybinds for helios threads"
  ;; loop over threadkeys
  (dolist (pair helios/threadkeys)
    ;; get name and unique letter of thread
    ;; and then get the thread itself
    (let* ((name (car pair))
           (letter (cdr pair))
           (thread (assoc name helios/threads)))
      ;; bind the letter key to a lambda function that spawns the thread buffer
      (evil-local-set-key 'normal (kbd letter)
                          `(lambda ()
                             (interactive)
                             (helios/spawn-buffer (car ',thread) #'helios/thread-content ',thread))))))

(defun helios/spawn-buffer (buffer-name content-function &optional args)
  "spawn a helios buffer with variable contents"
  (with-current-buffer (get-buffer-create (format "*helios/%s*" buffer-name))
    ;; inhibit read only
    (let ((inhibit-read-only t))
      (erase-buffer)
      (insert "\n")
      ;; call the function passed in to generate contents
      ;; pass along an optional argument if available
      (if args
          (funcall content-function args)
        (funcall content-function))

      ;; switch to buffer, set read only and go to origin point
      (switch-to-buffer (current-buffer))
      (read-only-mode t)
      (goto-char (point-min))

      ;; set fonts
      (setq font-lock-defaults nil)
      (setq helios-thread-font-lock
            '((".*!.*" ; lines containing !
               (0 'helios/font/exclamation nil))
              ("#[[:alnum:]]+" ; thread tags
               (0 'helios/font/thread-highlight t))
              ("#{[[:alnum:]]+}" ; command tags
               (0 'helios/font/command-highlight t))
              ("@.+" ; daily recall chunk descriptions
               (0 'helios/font/chunk-recall t))
              ("\".*\"" ; quotes (remove formatting)
               (0 'default t))))
      (setq font-lock-defaults '(helios-thread-font-lock))
      (font-lock-mode 1)

      ;; enable line wrapping, mixed pitch mode
      (visual-line-mode t)
      (mixed-pitch-mode 1)
      ;; set line spacing and window margins
      (setq-local line-spacing 8)
      (set-window-margins (selected-window) 4 4)
      ;; press q to return to dashboard
      (evil-local-set-key 'normal (kbd "q") 'helios))))

(defun helios/thread-content (thread)
  "render content for individual helios thread buffers"
  ;; get name, contents, and make buffer name
  (dolist (element (cdr thread))
    ;; insert single lines double spaced
    (when (stringp element)
      (insert element)
      (insert "\n\n"))
    ;; loop over chunks
    (when (listp element)
      ;; first element is the optional description
      (when (not (string-empty-p (car (last element))))
        ;; insert chunk description with font
        (insert (propertize (car (last element)) 'font-lock-face 'helios/font/chunk-description))
        (insert "\n"))
      ;; loop over chunk contents and insert, single spaced
      (dolist (line (reverse (butlast element)))
        (insert line)
        (insert "\n"))
      ;; pad newline at end
      (insert "\n"))))

(defun helios/threads-content ()
  "helios expansion buffer to display all threads"
  (insert (propertize "threads\n" 'font-lock-face 'helios/font/h2))
  ;; loop over threads and insert with keybind letter highlighted
  (mapcar (lambda (pair)
            (let* ((word (car pair))
                   (letter (cdr pair))
                   (match (string-match (regexp-quote letter) word 0)))
              (insert (substring word 0 (match-beginning 0)))
              (insert (propertize letter 'font-lock-face 'helios/font/emphasis))
              (insert (substring word (match-end 0)))
              (insert "\n")))
          helios/threadkeys)
  ;; switch to buffer and bind the keys
  (switch-to-buffer (current-buffer))
  (helios/generate-thread-binds))

(defun helios/todo-content ()
  "helios expansion buffer to display all todos"
  (insert (propertize "todo\n" 'font-lock-face 'helios/font/h2))
  (let ((completed '()))
    ;; loop over todos and save them for later if they are completed or insert into buffer if not
    (dolist (todo helios/todo)
      (if (string= "x" (cdr todo))
          (push (car todo) completed)
        (if (string-empty-p (cdr todo))
            (insert (format "• %s\n" (car todo)))
          (insert (format "• %s [%s]\n" (car todo) (cdr todo))))))

    ;; render completed heading if there are completed todos
    (if (> (length completed) 0)
        (insert (propertize "\ncompleted\n" 'font-lock-face 'helios/font/h4)))
    ;; loop and insert the completed todos in, greyed out
    (dolist (todo completed)
      (insert (propertize (format "• %s\n" todo) 'font-lock-face 'helios/font/inactive)))))

(defun helios ()
  "initialize helios"
  (interactive)
  (helios/load-file)
  (helios/generate-thread-keys)
  (helios/load-dashboard)
  (helios/generate-thread-binds))

;;; provide helios
(provide 'helios)
#+end_src

** init.el
#+begin_src emacs-lisp :tangle ~/.config/doom/init.el :mkdirp yes
;; -*- lexical-binding: t; -*-
(doom! :input

       :completion company ivy vertico

       :ui doom doom-dashboard (emoji +unicode) hl-todo modeline ophints
           (popup +defaults) (vc-gutter +pretty) vi-tilde-fringe workspaces zen

       :editor (evil +everywhere) file-templates fold snippets word-wrap

       :emacs dired electric undo vc

       :term eshell shell term vterm

       :checkers syntax

       :tools biblio debugger docker ein (eval +overlay) lookup lsp
              magit make pdf rgb tmux tree-sitter upload

       :os (:if IS-MAC macos) tty

       :lang (cc +lsp) common-lisp data emacs-lisp json javascript julia latex
             markdown ocaml org python (ruby +rails) (rust +lsp) sh web yaml

       :email

       :app calendar

       :config (default +bindings +smartparens))
#+end_src

** packages.el
#+begin_src emacs-lisp :tangle ~/.config/doom/packages.el
;; -*- no-byte-compile: t; -*-
(package! rainbow-mode)
(package! mixed-pitch)
(package! devdocs)
(package! olivetti)
#+end_src

** config.el
*** general settings
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
;; -*- lexical-binding: t; -*-
(setq doom-theme 'nyx
      doom-font (font-spec :family "Fira Code" :size 13 :height 1.0)
      doom-variable-pitch-font (font-spec :family "Palatino" :height 1.4)

      fancy-splash-image "~/selene.png"
      confirm-kill-emacs nil
      display-line-numbers-type 'relative

      comfy-modes '(org-mode devdocs-mode))

(setq-default indent-tabs-mode nil
              tab-width 4
              tab-stop-list ()
              indent-line-function 'insert-tab

              python-indent-guess-indent-offset nil
              python-indent-offset 4)

(push '(fullscreen . maximized) default-frame-alist)

(load-file "~/helios.el")
(require 'helios)
#+end_src

mac specific settings
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(when (equal system-type 'darwin)
  ;; make command [⌘] => meta & option [⌥] => super
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'super))
#+end_src

fix focus when starting emacsclient
https://korewanetadesu.com/emacs-on-os-x.html
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(when (featurep 'ns)
  (defun ns-raise-emacs ()
    "Raise Emacs."
    (ns-do-applescript "tell application \"Emacs\" to activate"))

  (defun ns-raise-emacs-with-frame (frame)
    "Raise Emacs and select the provided frame."
    (with-selected-frame frame
      (when (display-graphic-p)
        (ns-raise-emacs))))

  (add-hook 'after-make-frame-functions 'ns-raise-emacs-with-frame)

  (when (display-graphic-p)
    (ns-raise-emacs)))
#+end_src

popup rules
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(set-popup-rules!
  '(("^\\*doom:vterm" :side bottom :size 0.32)))
#+end_src

*** keymaps
misc.
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(map! :leader
      ;; selene keyspace
      "s s" #'(lambda () (interactive) (find-file "~/selene.org"))
      "s h" #'(lambda () (interactive) (find-file "~/helios.nyx"))
      "s o" #'olivetti-mode

      "v" #'+vterm/toggle
      "d" #'devdocs-lookup

      "r c" #'(lambda () (interactive) (selene/run-clang (buffer-file-name)))
      "r p" #'(lambda () (interactive) (selene/run-python (buffer-file-name)))

      "! l" #'flycheck-list-errors
      "! n" #'flycheck-next-error
      "! p" #'flycheck-previous-error

      "@" #'helios)
#+end_src

evil
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(define-key evil-motion-state-map (kbd "C-`") 'evil-emacs-state)
(define-key evil-emacs-state-map (kbd "C-`") 'evil-exit-emacs-state)
#+end_src

disable control-scroll zooming in accidentally
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(define-key global-map (kbd "<C-wheel-up>") #'ignore)
(define-key global-map (kbd "<C-wheel-down>") #'ignore)
#+end_src

*** functions
change hook
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(defun selene/on-change ()
  ;; ignore helios buffers
  (unless (string-match "^\*helios" (buffer-name))
    ;; comfy line height for comfy serif font
    (when (member major-mode comfy-modes)
      (mixed-pitch-mode 1)
      (setq-local line-spacing 6))
    (when (not (member major-mode comfy-modes))
      (mixed-pitch-mode -1)
      (setq-local line-spacing 6)))

  ;; check if .nyx file
  (when (buffer-file-name)
    (when (string= (file-name-extension (buffer-file-name)) "nyx")
      (mixed-pitch-mode 1)
      (setq-local line-spacing 6)
      (visual-line-mode t)
      (set-window-margins (selected-window) 4 4))
      (advice-add 'basic-save-buffer :after (lambda (_) (selene/on-change))))

  ;; hide cursor on splash dash
  (when (eq major-mode '+doom-dashboard-mode)
    (internal-show-cursor (selected-window) nil))
  (when (not (eq major-mode '+doom-dashboard-mode))
    (internal-show-cursor (selected-window) t)))
#+end_src

run programs in vterm
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(defun selene/run-clang (file-name)
  (interactive)
  (vterm)
  (set-buffer "*vterm*")
  (term-send-raw-string (concat "clang++ -std=c++11 \"" file-name "\" && ./a.out\n")))

(defun selene/run-python (file-name)
  (interactive)
  (vterm)
  (set-buffer "*vterm*")
  (term-send-raw-string (concat "python3 \"" file-name "\"\n")))
#+end_src

*** hooks
on buffer list change
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(add-hook 'buffer-list-update-hook 'selene/on-change)
#+end_src

2 space tab in lisp modes
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(add-hook 'lisp-mode-hook (lambda () (setq-local tab-width 2)))
(add-hook 'emacs-lisp-mode-hook (lambda () (setq-local tab-width 2)))
#+end_src

fix issue of small variable-pitch text after new client frame
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(add-hook 'server-after-make-frame-hook
  (lambda ()
    (setq-local mixed-pitch-set-height t)
    (set-face-attribute 'variable-pitch nil :height 1.4)))
#+end_src

doom dashboard
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-loaded)
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-footer)

(add-hook! '+doom-dashboard-functions :append
  (insert (+doom-dashboard--center +doom-dashboard--width "< w e l c o m e ,   m o f e i >") "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"))
#+end_src

misc.
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(remove-hook 'doom-first-input-hook #'evil-snipe-mode) ; evil s functionality
#+end_src

*** org
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(setq org-directory "~/org/")
(setq org-log-done 'time)
#+end_src

make org pretty
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(setq org-hide-emphasis-markers t)

(font-lock-add-keywords 'org-mode
  '(("^ *\\([-]\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

mixed-pitch for org
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(use-package! mixed-pitch
  :hook (org-mode . mixed-pitch-mode)
  :config
    (setq mixed-pitch-set-height t)
    (set-face-attribute 'variable-pitch nil :height 1.4))
#+end_src

org-capture
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(setq org-default-notes-file (concat org-directory "/capture.org"))
(map! :leader "x" #'org-capture)
#+end_src

** nyx colorscheme
#+begin_src emacs-lisp :tangle ~/.config/doom/themes/nyx-theme.el :mkdirp yes
(require 'doom-themes)

(defgroup nyx-theme nil
  "Options for doom-themes"
  :group 'doom-themes)

(def-doom-theme nyx
  "A dark theme inspired by the moon"

  ;; name        default   256       16
  ((bg         '("#18131A" nil       nil            ))
   (bg-alt     '("#18131A" nil       nil            ))
   (base0      '("#261e29" "#261e29" "black"        ))
   (base1      '("#2f2633" "#2f2633" "brightblack"  ))
   (base2      '("#5e4b66" "#5e4b66" "brightblack"  ))
   (base3      '("#745f7d" "#745f7d" "brightblack"  ))
   (base4      '("#8b7694" "#8b7694" "brightblack"  ))
   (base5      '("#9483a8" "#9483a8" "brightblack"  ))
   (base6      '("#ae9fc9" "#ae9fc9" "brightblack"  ))
   (base7      '("#b0bae3" "#b0bae3" "brightblack"  ))
   (base8      '("#c0caf5" "#c0caf5" "white"        ))
   (fg         '("#a9b1d6" "#a9b1d6" "white"        ))
   (fg-alt     '("#c0caf5" "#c0caf5" "brightwhite"  ))

   (grey       '("#8189af" "#8189af" "brightblack"  ))
   (red        '("#f7768e" "#f7768e" "red"          ))
   (orange     '("#ff9e64" "#ff9e64" "brightred"    ))
   (green      '("#73daca" "#73daca" "green"        ))
   (teal       '("#2ac3de" "#2ac3de" "brightgreen"  ))
   (yellow     '("#e0af68" "#e0af68" "yellow"       ))
   (blue       '("#7aa2f7" "#7aa2f7" "brightblue"   ))
   (dark-blue  '("#565f89" "#565f89" "blue"         ))
   (magenta    '("#bb9af7" "#bb9af7" "magenta"      ))
   (violet     '("#9aa5ce" "#9aa5ce" "brightmagenta"))
   (cyan       '("#b4f9f8" "#b4f9f8" "brightcyan"   ))
   (dark-cyan  '("#7dcfff" "#7dcfff" "cyan"         ))

   (highlight      cyan)
   (vertical-bar   base2)
   (selection      dark-blue)
   (builtin        magenta)
   (comments       base4)
   (doc-comments   (doom-lighten comments 0.2))
   (constants      violet)
   (functions      green)
   (keywords       blue)
   (methods        cyan)
   (operators      blue)
   (type           red)
   (strings        yellow)
   (variables      magenta)
   (numbers        magenta)
   (region         (doom-darken magenta 0.8))
   (error          red)
   (warning        yellow)
   (success        green)
   (vc-modified    orange)
   (vc-added       green)
   (vc-deleted     red)

   (modeline-fg     fg)
   (modeline-fg-alt (doom-blend violet base4 0.2))

   (modeline-bg (doom-darken bg-alt 0.2))
   (modeline-bg-l base2)
   (modeline-bg-inactive (doom-darken bg 0.1))
   (modeline-bg-inactive-l `(,(doom-darken (car bg-alt) 0.05) ,@(cdr base1))))

  ((font-lock-comment-face
    :foreground comments
    :weight 'regular)
   (font-lock-doc-face
    :inherit 'font-lock-comment-face
    :foreground doc-comments
    :weight 'regular)

   ((line-number &override) :foreground base4)
   ((line-number-current-line &override) :foreground cyan)

   (doom-modeline-bar :background highlight)
   (doom-modeline-project-dir :foreground violet :weight 'bold)
   (doom-modeline-buffer-file :weight 'regular)

   (mode-line :background modeline-bg :foreground modeline-fg)
   (mode-line-inactive :background modeline-bg-inactive :foreground modeline-fg-alt)
   (mode-line-emphasis :foreground highlight)

   (magit-blame-heading :foreground orange :background bg-alt)
   (magit-diff-removed :foreground (doom-darken red 0.2) :background (doom-blend red bg 0.1))
   (magit-diff-removed-highlight :foreground red :background (doom-blend red bg 0.2) :bold bold)

   (evil-ex-lazy-highlight :background base2)

   (css-proprietary-property :foreground orange)
   (css-property             :foreground green)
   (css-selector             :foreground blue)

   (markdown-markup-face     :foreground base5)
   (markdown-header-face     :inherit 'bold :foreground red)
   (markdown-code-face       :background base1)
   (mmm-default-submode-face :background base1)

   (org-block            :background (doom-darken bg-alt 0.2))
   (org-level-1          :foreground base8 :weight 'bold :height 1.25)
   (org-level-2          :foreground base7 :weight 'bold :height 1.1)
   (org-level-3          :foreground base6 :bold bold :height 1.0)
   (org-level-4          :foreground base5 :bold bold :height 1.0)
   (org-ellipsis         :underline nil :background bg-alt     :foreground grey)
   (org-quote            :background base1)
   (org-checkbox-statistics-done :foreground base2 :weight 'normal)
   (org-done nil)
   (org-done :foreground green :weight 'normal)
   (org-headline-done :foreground base3 :weight 'normal :strike-through t)
   (org-date :foreground orange)
   (org-code :foreground dark-blue)
   (org-special-keyword :foreground base8 :underline t)
   (org-document-title :foreground base8 :weight 'bold :height 1.5)
   (org-document-info-keyword :foreground base4 :height 0.75)
   (org-block-begin-line :foreground base4 :height 0.8)
   (org-meta-line :foreground base4 :height 0.65)
   (org-list-dt :foreground magenta)

   (org-todo-keyword-faces
    '(("TODO" :foreground base6 :weight normal :underline t)
      ("WAITING" :foreground magenta :weight normal :underline t)
      ("INPROGRESS" :foreground blue :weight normal :underline t)
      ("DONE" :foreground green :weight normal :underline t)
      ("CANCELLED" :foreground red :weight normal :underline t)))

   (org-priority-faces '((65 :foreground orange)
                         (66 :foreground yellow)
                         (67 :foreground cyan)))

   (helm-candidate-number :background blue :foreground bg)

   (web-mode-current-element-highlight-face :background dark-blue :foreground bg)

   (wgrep-face :background base1)

   (ediff-current-diff-A        :foreground red   :background (doom-lighten red 0.8))
   (ediff-current-diff-B        :foreground green :background (doom-lighten green 0.8))
   (ediff-current-diff-C        :foreground blue  :background (doom-lighten blue 0.8))
   (ediff-current-diff-Ancestor :foreground teal  :background (doom-lighten teal 0.8))

   (tooltip :background base1 :foreground fg)

   (ivy-posframe :background base0)

   (lsp-ui-doc-background      :background base0)
   (lsp-face-highlight-read    :background (doom-blend red bg 0.3))
   (lsp-face-highlight-textual :inherit 'lsp-face-highlight-read)
   (lsp-face-highlight-write   :inherit 'lsp-face-highlight-read)
 ))
#+end_src
