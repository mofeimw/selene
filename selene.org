#+title: selene: greek goddess of the moon
#+author: mofei
** shell scripts
build emacs
#+begin_src shell :tangle ~/build-emacs.sh :tangle-mode (identity #o755)
#!/bin/sh
git clone https://git.savannah.gnu.org/git/emacs.git --branch emacs-29 --single-branch
cd emacs
git checkout emacs-29
# or checkout desired version

./autogen.sh

./configure --with-native-compilation --with-json --with-tree-sitter --with-cairo --with-xwidgets --without-dbus

# nproc for number of cores to speed build along
# gmake builds emacs executable in src folder
gmake -j$(nproc)
# gmake install creates self contained .app, but i don't need

# add binaries to path -> .zshrc
export PATH="$PATH:$HOME/emacs/src"
# emacsclient is in lib-src
export PATH="$PATH:$HOME/emacs/lib-src"
#+end_src

selene
#+begin_src shell :tangle ~/selene.sh :tangle-mode (identity #o755)
#!/bin/sh
if [ "$1" = "launcher" ]; then
    # skhd doesn't recognize path
    emacsclient="$HOME/emacs/lib-src/emacsclient"
    # check if emacsclient is not already open
    if [ $(ps aux | grep -v grep | grep -ci "emacsclient") -eq 0 ]; then
        # create a new frame connected to server and focus it
        $emacsclient -c -e  "(select-frame-set-input-focus (selected-frame))"
    fi
    # focus existing window
    $emacsclient -e  "(select-frame-set-input-focus (selected-frame))"
    exit
elif [ "$1" = "diff" ]; then
    diff ~/selene.org ~/selene/selene.org
    exit
elif [ "$1" = "tangle" ]; then
    emacsclient -e '(org-babel-tangle-file "~/selene.org")'
    exit
elif [ "$1" = "kill" ]; then
    emacsclient -e "(kill-emacs)"
    exit
elif [ "$1" = "restart" ]; then
    emacsclient -e "(kill-emacs)"
elif [ "$1" = "retangle" ]; then
    emacsclient -e '(org-babel-tangle-file "~/selene.org")'
    emacsclient -e "(kill-emacs)"
fi

emacs --daemon
#+end_src

** helios
#+begin_src emacs-lisp :tangle ~/helios/helios.el :mkdirp yes
;; -*- lexical-binding: t; -*-
(require 'cl-lib)
(require 'calendar)
(require 'svg)

(load-file "~/helios/dashboard.el")
(load-file "~/helios/parser.el")
(load-file "~/helios/commands.el")
(load-file "~/helios/buffers.el")
(load-file "~/helios/threads.el")
(load-file "~/helios/recall.el")
(load-file "~/helios/todo.el")
(load-file "~/helios/calendar.el")
(load-file "~/helios/utilities.el")

(define-derived-mode nyx-mode fundamental-mode "nyx"
  "major mode for editing .nyx files"
  ;; remove pesky autoindented tab after newlines
  (setq-local indent-line-function 'ignore))
(add-to-list 'auto-mode-alist '("\\.nyx\\'" . nyx-mode))

(define-minor-mode helios-mode
  "minor mode for helios buffers"
  :lighter "helios"
  :global nil
  ;; toggle mixed pitch mode and cursor color
  (if helios-mode
      (progn
        (mixed-pitch-mode 1)
        (setq-local evil-normal-state-cursor "#18131B"))
    (progn
      (mixed-pitch-mode -1)
      (setq-local evil-normal-state-cursor '("#b4f9f8" box)))))

(defface helios/font/h1
  '((t (:foreground "#e0af68" :height 600 :family "Egmond")))
  "helios header 1 font")
(defface helios/font/h2
  '((t (:foreground "#b4f9f8" :weight bold :height 210)))
  "helios header 2 font")
(defface helios/font/h4
  '((t (:foreground "#bb9af7" :weight bold :height 200)))
  "helios header 4 font")
(defface helios/font/quote
  '((t (:foreground "#bb9af7" :slant italic :height 222 :family "Yrsa")))
  "helios quote font")
(defface helios/font/reminder
  '((t (:foreground "#f7768e" :height 144 :family "Annie Use Your Telescope")))
  "helios reminder font")
(defface helios/font/code
  '((t (:foreground "#7aa2f7" :height 145 :family "Fira Code")))
  "helios monospace/code font")
(defface helios/font/exclamation
  '((t (:foreground "#f7768e")))
  "helios exclamation font")
(defface helios/font/thread-highlight
  '((t (:foreground "#b4f9f8" :weight bold)))
  "helios thread highlight font")
(defface helios/font/command-highlight
  '((t (:foreground "#bb9af7" :weight bold)))
  "helios command highlight font")
(defface helios/font/chunk-description
  '((t (:foreground "#7aa2f7" :weight bold)))
  "helios chunk description font")
(defface helios/font/chunk-recall
  '((t (:foreground "#e0af68" :weight bold)))
  "helios chunk recall font")
(defface helios/font/emphasis
  '((t (:foreground "#b4f9f8")))
  "helios emphasis font")
(defface helios/font/bold-emphasis
  '((t (:foreground "#b4f9f8" :weight bold)))
  "helios bold emphasis font")
(defface helios/font/inactive
  '((t (:foreground "#8b7694")))
  "helios inactive font")

(defvar helios/file "~/helios.nyx")
(defvar helios/timers '())

(defun helios ()
  "helios"
  (interactive)
  (helios/load-file)
  (helios/dashboard))

(defun helios/load-file (&optional include)
  "load helios.nyx"
  ;; init/reset global variables unless including
  (unless include
    (setq helios/threads '())
    (setq helios/threadkeys '())
    (setq helios/quotes '())
    (setq helios/reminders '())
    (setq helios/countdown '())
    (setq helios/todo '())
    (setq helios/events '())
    (setq helios/timeblocks '())
    (setq helios/notifications '())

    (setq helios/parser/state 'normal)
    (setq helios/parser/suppress nil)
    (setq helios/parser/buffer '())
    (setq helios/parser/chunk '())
    (setq helios/parser/chunk-threads '())
    (setq helios/parser/recall-date nil)

    (setq helios/todo/active 0)

    (setq helios/calendar/date (calendar-current-date))
    (setq helios/calendar/period 'month)

    (setq helios/current-time (current-time)))

  ;; use default file if not including
  (let ((file (or include helios/file)))
    ;; insert contents into a temporary buffer
    (with-temp-buffer
      (insert-file-contents file)
      (goto-char (point-min))
      ;; read line by line
      (while (not (eobp))
        (let ((line (buffer-substring-no-properties
                     (line-beginning-position)
                     (line-end-position))))
          ;; parse each line
          (helios/parser line)
          (forward-line 1)))
      ;; flush out buffer
      (helios/parser ""))
    (message "[helios] parsed %s" file))

  ;; setup after loading file
  (helios/todo/sort)
  (helios/utility/schedule-notifications)
  (helios/threads/binds/generate))

(provide 'helios)
#+end_src

dashboard
#+begin_src emacs-lisp :tangle ~/helios/dashboard.el
(defun helios/dashboard ()
  "load helios dashboard"
  (interactive)
  ;; set left margin to 2/5 of window width
  (setq margin-left (* (/ (window-total-width) 5) 2))
  ;; responsive - if window width is less than 100, set margin to 1/3 of width
  (when (< (window-total-width) 100)
    (setq margin-left (/ (window-total-width) 3)))

  ;; get or create helios buffer
  (with-current-buffer (get-buffer-create "*helios*")
    ;; inhibit read only in buffer and render dashboard
    (let ((inhibit-read-only t))
      (erase-buffer)
      (insert "H E L I O S\n")
      (helios/dashboard/quote)
      (helios/dashboard/reminders)
      (helios/dashboard/countdown)
      (helios/dashboard/threads)
      (helios/dashboard/todo)))

  ;; switch to helios buffer and refresh buffer
  (switch-to-buffer "*helios*")
  (helios/buffer/hook)

  ;; set margins, enable line wrapping, set read only and go to origin point
  (set-window-margins (selected-window) margin-left 8)
  (visual-line-mode t)
  (read-only-mode 1)
  (goto-char (point-min))

  ;; set fonts
  (setq font-lock-defaults nil)
  (setq helios-dashboard-font-lock
        '(("H E L I O S"
           (0 'helios/font/h1 t))
          ("^\".+\"$"
           (0 'helios/font/quote t))
          ("^<.+>$"
           (0 'helios/font/code t))
          ("^\\<\\(threads\\|todo\\)\\>$"
           (0 'helios/font/h2 t))
          ("^.*!!.*$"
           (0 'helios/font/exclamation t))
          ("\\[.*\\]"
           (0 'helios/font/emphasis t))
          ("\\[.* day.*\\]"
           (0 'helios/font/exclamation t))))
  (setq font-lock-defaults '(helios-dashboard-font-lock))
  (setq-local line-spacing 18)
  (font-lock-mode 1)

  ;; neutralize mouse
  (helios/utility/neutralize-mouse)

  ;; bind threads
  (helios/threads/binds/map)

  ;; bind threads view
  (evil-local-set-key 'normal (kbd "1")
                      `(lambda ()
                         (interactive)
                         (funcall 'helios/buffer/spawn "threads" #'helios/threads/view)))
  ;; bind recall view
  (evil-local-set-key 'normal (kbd "2")
                      `(lambda ()
                         (interactive)
                         (funcall 'helios/buffer/spawn "recall" #'helios/recall/view)))
  (evil-local-set-key 'normal (kbd "@")
                      `(lambda ()
                         (interactive)
                         (funcall 'helios/buffer/spawn "recall" #'helios/recall/view)))
  ;; bind todo view
  (evil-local-set-key 'normal (kbd "3")
                      `(lambda ()
                         (interactive)
                         (funcall 'helios/buffer/spawn "todo" #'helios/todo/view)))
  ;; bind calendar view
  (evil-local-set-key 'normal (kbd "4")
                      `(lambda ()
                         (interactive)
                         (funcall 'helios/buffer/spawn "calendar" #'helios/calendar/view)))
  (evil-local-set-key 'normal (kbd "?")
                      `(lambda ()
                         (interactive)
                         (funcall 'helios/buffer/spawn "calendar" #'helios/calendar/view)))

  ;; hook into buffer list update
  (add-hook 'buffer-list-update-hook #'helios/buffer/hook))

(defun helios/dashboard/quote ()
  "helios dashboard quote section"
  ;; pick a random quote
  (when (> (length helios/quotes) 0)
    (let ((quote (nth (random (length helios/quotes)) helios/quotes)))
      (insert (format "\"%s\"\n" quote)))))

(defun helios/dashboard/reminders ()
  "helios dashboard reminders section"
  ;; loop over reminders and render with annie use your telescope :)
  (when helios/reminders
    (dolist (reminder helios/reminders)
      (when (equal (car reminder) (calendar-current-date))
        (insert (propertize (cdr reminder) 'font-lock-face 'helios/font/reminder))
        (insert "\n")))))

(defun helios/dashboard/countdown ()
  "helios dashboard countdown section"
  ;; check if countdown is set and hasn't passed
  (when helios/countdown
    (if (>= (cdr helios/countdown) 0)
        ;; insert formatted countdown depending on if description is provided
        (if (string-empty-p (car helios/countdown))
            (insert (format "<%d days remaining>\n" (cdr helios/countdown)))
          (insert (format "<%s: %d days remaining>\n" (car helios/countdown) (cdr helios/countdown)))))))

(defun helios/dashboard/threads ()
  "helios dashboard threads section"
  ;; insert heading if there are threads
  (if (> (length helios/threads) 0)
      (insert "threads\n"))
  (let ((count 0))
    (catch 'break
      ;; loop over threadkeys list
      (mapcar (lambda (pair)
                ;; break to only show first 4 threads
                (when (> count 3)
                  (throw 'break nil))
                ;; insert word formatted to emphasize keybind
                ;; split where first occurance of letter is and piece together
                (let* ((word (car pair))
                       (letter (cdr pair))
                       (match (string-match (regexp-quote letter) word 0)))
                  (insert (substring word 0 (match-beginning 0)))
                  (insert (propertize letter 'font-lock-face 'helios/font/emphasis))
                  (insert (substring word (match-end 0)))
                  (insert "\n")
                  (setq count (+ count 1))))
              helios/threadkeys))))

(defun helios/dashboard/todo ()
  "helios dashboard todo section"
  ;; insert heading if there are active todos
  (if (> helios/todo/active 0)
      (insert "todo\n"))
  ;; loop over todos
  (let ((count 0))
    (catch 'break
      (dolist (todo helios/todo)
        ;; break to only show first 4 todos
        (when (> count 3)
          (throw 'break nil))
        ;; insert todo bullet if active
        (unless (string= "x" (cdr todo))
          (setq count (+ count 1))
          ;; format depending on whether deadline is provided
          (if (string-empty-p (cdr todo))
              (insert (format "• %s\n" (car todo)))
            (insert (format "• %s [%s]\n" (car todo) (cdr todo)))))))))
#+end_src

parser
#+begin_src emacs-lisp :tangle ~/helios/parser.el
(defun helios/parser (line)
  "helios parser"
  ;; don't suppress to main by default
  (setq helios/parser/suppress nil)

  ;; state-based parsing
  (cond
   ;; normal state
   ((eq helios/parser/state 'normal)
    (helios/parser/state/normal line))
   ;; chunk state
   ((eq helios/parser/state 'chunk)
    (helios/parser/state/chunk line)))

  ;; add non-empty lines to main thread if not suppressed
  (unless (or (string= line "") helios/parser/suppress)
    (helios/threads/add "main" line)))

(defun helios/parser/state/normal (line)
  "helios parser normal state"
  (cond
   ;; comment
   ((string-match "^;;.*$" line) nil)

   ;; chunk
   ((string-match "^~.*$" line)
    (helios/parser/chunk line))

   ;; command
   ((string-match "^.*#{\\([a-zA-Z0-9_-]+\\)}.*$" line)
    (helios/parser/command line))

   ;; threads
   ((string-match "^.*#[a-zA-Z0-9_-]+.*$" line)
    (helios/parser/threads line))

   ;; blank line
   ((string= line "")
    ;; add buffered lines to main thread
    ;; as single line
    (if (= (length helios/parser/buffer) 1)
        (helios/threads/add "main" (car helios/parser/buffer)))
    ;; or implicit chunk
    (if (> (length helios/parser/buffer) 1)
        (helios/threads/add "main" (append helios/parser/buffer '(""))))
    ;; clear buffer
    (setq helios/parser/buffer nil))

   ;; line
   (t
    ;; buffer line and suppress
    (push line helios/parser/buffer)
    (setq helios/parser/suppress t))))

(defun helios/parser/threads (line)
  "helios parse threads"
  (let ((start 0))
    ;; loop through to find all threads
    (while (string-match "#\\([a-zA-Z0-9_-]+\\)" line start)
      ;; extract name of thread and append to it
      (let ((thread (match-string 1 line)))
        (helios/threads/add thread line))
      ;; move start flag to end of match
      (setq start (match-end 0)))))

(defun helios/parser/command (line)
  "helios parse command"
  ;; extract name of command
  (let* ((command (match-string 1 line))
         ;; grab symbol of command function
         (command-function (intern (concat "helios/command/" command)))
         ;; remove command tag from line and trim, considering remainder as arguments
         (args (string-trim (replace-regexp-in-string "#{.*}" "" line))))
    ;; check if command function is bound and call with arguments or log warning
    (if (fboundp command-function)
        (funcall command-function args)
      (message "[helios] command not found: %s" command))))

(defun helios/parser/chunk (line)
  "helios parse chunk opening"
  ;; enter chunk state
  (setq helios/parser/state 'chunk)
  ;; suppress ~
  (setq helios/parser/suppress t)

  ;; see if it is plain or elaborate
  (if (string-match "^~\\s-*\\([@./'# a-zA-Z0-9_-]*\\)$" line)
      ;; elaborate (has description)
      (let ((description (match-string 1 line)))
        ;; store extracted description
        (push description helios/parser/chunk)
        ;; process daily recall
        (if (string-match "^@\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\).*" description)
            (setq helios/parser/recall-date (match-string 1 description)))
        ;; process threads
        (when (string-match-p "#[a-zA-Z0-9_-]+" line)
          (let ((start 0))
            ;; loop through to find all threads
            (while (string-match "#\\([a-zA-Z0-9_-]+\\)" line start)
              ;; push and then move flag forward
              (push (match-string 1 line) helios/parser/chunk-threads)
              (setq start (match-end 0))))))
    ;; plain
    (push "" helios/parser/chunk)))

(defun helios/parser/state/chunk (line)
  "helios parser chunk state"
  (setq helios/parser/suppress t)
  (if (string= line "~")
      ;; closing chunk
      (progn
        ;; add to main thread
        (helios/threads/add "main" helios/parser/chunk)
        ;; add to recall thread if recall
        (if helios/parser/recall-date
            (helios/threads/add "recall" helios/parser/chunk))
        ;; add to thread(s) if tagged
        (dolist (thread helios/parser/chunk-threads)
          (helios/threads/add thread helios/parser/chunk))
        ;; reset chunk variables
        (setq helios/parser/chunk '())
        (setq helios/parser/chunk-threads '())
        (setq helios/parser/recall-date nil)
        ;; exit chunk state
        (setq helios/parser/state 'normal))
    ;; inside chunk
    (progn
      ;; parse for threads still
      (helios/parser/threads line)
      ;; add to chunk
      (push line helios/parser/chunk))))
#+end_src

commands
#+begin_src emacs-lisp :tangle ~/helios/commands.el
(defun helios/command/countdown (args)
  "helios countdown command"
  (cond
   ;; disable countdown if arguments are "off" or empty
   ((or (string= args "") (string= args "off"))
    (setq helios/countdown '()))

   ;; parse arguments if matching format: date first, separated by . or /, then optional description in brackets
   ((string-match "\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\)\\s-*\\(?:\\[\\(.*?\\)\\]\\)?" args)
    ;; extract optional description, parse date string, get today's date, and calculate number of days between
    (let* ((description (or (match-string 3 args) ""))
           (date (helios/utility/parse-date args))
           (today (calendar-current-date))
           (days-between (- (calendar-absolute-from-gregorian date)
                            (calendar-absolute-from-gregorian today))))
      ;; set countdown variable to cons cell of description and number of days between
      (setq helios/countdown (cons description days-between))))

   ;; invalid syntax - log warning
   (t
    (message "[helios|countdown] invalid syntax: %s" args))))

(defun helios/command/todo (args)
  "helios todo command"
  ;; test if arguments contain optional brackets
  (if (string-match "\\[\\(.*\\)\\]" args)
      ;; extract bracket contents and consider remains as task
      (let* ((bracket-contents (match-string 1 args))
             (task (string-trim (replace-regexp-in-string (format "\\[%s\\]" bracket-contents) "" args))))
        ;; switch conditional cases cascade down
        (cond
         ;; [x] indicates marking todo as completed
         ((string= bracket-contents "x")
          ;; set found flag to false
          (let ((found nil))
            ;; loop over all todos
            (dolist (item helios/todo)
              ;; set found flag to true and mark todo as completed when found
              ;; decrement to keep count of active uncompleted todos
              (when (string= task (car item))
                (setq found t)
                (setcdr item "x")
                (setq helios/todo/active (- helios/todo/active 1))))
            ;; log warning if todo was never found
            (unless found
              (message "[helios|todo] task not found: %s" task))
            ;; remove from calendar
            (setq helios/events (delq (rassoc task helios/events) helios/events))))

         ;; deadline in the form of date with . or / separators and month, day, year order
         ((string-match "[0-9]+\\([/.]\\)[0-9]+\\1[0-9]+" bracket-contents)
          ;; push cons cell of task and date string to todos
          (push (cons task bracket-contents) helios/todo)
          ;; add parsed date to calendar
          (push (cons (helios/utility/parse-date bracket-contents) task) helios/events)
          ;; keep track of active todos
          (setq helios/todo/active (+ helios/todo/active 1)))

         ;; catchall indicates no valid syntax was matched
         ;; invalid syntax - log warning
         (t
          (message "[helios|todo] invalid syntax: %s" args))))

    ;; with no brackets, simply push task with no deadline
    (progn
      (push (cons (string-trim args) "") helios/todo)
      ;; make sure to update todo count
      (setq helios/todo/active (+ helios/todo/active 1)))))

(defun helios/command/reminder (args)
  "helios reminder command"
  (if (string-match "\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\).*" args)
      ;; extract date string, remainder as reminder, then parse date
      (let* ((date-string (match-string 1 args))
             (reminder (string-trim (replace-regexp-in-string date-string "" args)))
             (date (helios/utility/parse-date args)))
        ;; push as cons cell into reminders list
        (push (cons date reminder) helios/reminders))
    (message "[helios|reminder] invalid syntax: %s" args)))

(defun helios/command/schedule (args)
  "helios schedule command"
  (if (string-match "\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\).*" args)
      ;; extract date string, remainder as event, then parse date
      (let* ((date-string (match-string 1 args))
             (event (string-trim (replace-regexp-in-string date-string "" args)))
             (date (helios/utility/parse-date args))
             ;; get today's date and parse times from event
             (today (calendar-current-date))
             (time (helios/utility/parse-time event)))
        ;; push as cons cell into events list
        (push (cons date event) helios/events)
        ;; event is today and contains a time
        (when (and (equal date today) time)
          ;; schedule starting notification
          (push (cons time (format "[%s] is starting" event)) helios/notifications)
          ;; as well as heads up notifications 5 and 10 minutes before
          (let ((five-before (helios/utility/minutes-before time 5))
                (ten-before (helios/utility/minutes-before time 10)))
            (push (cons five-before (format "[%s] is starting in 5 minutes" event)) helios/notifications)
            (push (cons ten-before (format "[%s] is starting in 10 minutes" event)) helios/notifications))))
    (message "[helios|schedule] invalid syntax: %s" args)))

(defun helios/command/timeblock (args)
  "helios timeblock command"
  (if (string-match "\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\)\\s-\\[.*\\]+" args)
      ;; extract date, remainder as blocks, then parse date
      (let* ((date-string (match-string 1 args))
             (blocks (string-trim (replace-regexp-in-string date-string "" args)))
             (date (helios/utility/parse-date args))
             ;; get current date
             (today (calendar-current-date))
             ;; init variables for while loop
             (timeblocks '())
             (start 0))
        ;; loop over every block
        (while (string-match "\\[\\([0-9]+:[0-9]+\\)\\(?:-\\([0-9]+:[0-9]+\\)\\)?\\s-+\\(.*?\\)\\]" blocks start)
          ;; extract start time, end time, and event
          (let ((start-time-string (match-string 1 blocks))
                (end-time-string (match-string 2 blocks))
                (start-time '())
                (end-time '())
                (event (match-string 3 blocks)))
            ;; update the start position to regex match end for next iteration
            (setq start (match-end 0))

            ;; parse time strings afterwards to avoid interfering with match end
            (setq start-time (helios/utility/parse-time start-time-string))
            ;; end time is optional
            (if end-time-string
                ;; parse if given
                (setq end-time (helios/utility/parse-time end-time-string))
              (progn
                ;; deep copy start time
                (setq end-time (cons (car start-time) (cdr start-time)))
                (if (<= (car end-time) 24)
                    ;; otherwise default to 1 hour block
                    (setcar end-time (+ (car end-time) 1)))))

            ;; notify today's blocks
            (when (equal date today)
              ;; push start and end notifications
              (push (cons start-time (format "[%s] is starting" event)) helios/notifications)
              (push (cons end-time (format "[%s] is ending" event)) helios/notifications)
              ;; calculate 5 and 10 minutes before start and push those notifications
              (let ((five-before (helios/utility/minutes-before start-time 5))
                    (ten-before (helios/utility/minutes-before start-time 10)))
                (push (cons five-before (format "[%s] is starting in 5 minutes" event)) helios/notifications)
                (push (cons ten-before (format "[%s] is starting in 10 minutes" event)) helios/notifications)))

            ;; push as nested cons cells to temporary gathering list
            (push (cons (cons start-time end-time) event) timeblocks)))
        ;; store all blocks consed with date
        (push (cons date timeblocks) helios/timeblocks))
    (message "[helios|timeblock] invalid syntax: %s" args)))

(defun helios/command/quote (args)
  "helios quote command"
  ;; add to quote bank
  (push args helios/quotes))

(defun helios/command/include (args)
  "helios include command"
  ;; add include line before including file instead of after
  (helios/threads/add "main" (format "#{include} %s" args))
  ;; load file if it exists
  (if (file-exists-p args)
      (helios/load-file args)
    (message "[helios|include] file not found: %s" args))
  ;; suppress because line was already pushed
  (setq helios/parser/suppress t))
#+end_src

buffers
#+begin_src emacs-lisp :tangle ~/helios/buffers.el
(defun helios/buffer/spawn (buffer-name content-function &optional args)
  "spawn a helios buffer with variable contents"
  (with-current-buffer (get-buffer-create (format "*helios/%s*" buffer-name))
    ;; inhibit read only
    (let ((inhibit-read-only t))
      (erase-buffer)
      (insert "\n")

      ;; call the function passed in to generate contents
      ;; pass along an optional argument if available
      (if args
          (funcall content-function args)
        (funcall content-function))

      ;; switch to buffer, set read only and go to origin point
      (switch-to-buffer (current-buffer))
      (read-only-mode t)
      (goto-char (point-min))

      ;; set fonts
      (setq font-lock-defaults nil)
      (setq helios-thread-font-lock
            '((".*!!.*" ; important lines!!
               (0 'helios/font/exclamation nil))
              ("\\*.*\\*" ; bold emphasis
               (0 'helios/font/bold-emphasis t))
              ("^#[[:alnum:]]+" ; thread tags
               (0 'helios/font/thread-highlight t))
              ("^#{[[:alnum:]]+}" ; command tags
               (0 'helios/font/command-highlight t))
              ("\".*\"" ; quotes (remove formatting)
               (0 'default t))
              ("^;;.*$" ; comments
               (0 'helios/font/inactive t))
              ("@.+" ; daily recall chunk descriptions
               (0 'helios/font/chunk-recall t))
              ("^\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\).*" ; daily recall dates
               (0 'helios/font/chunk-recall t))
              ("\\[.*\\]" ; normal todo items
               (0 'helios/font/emphasis t))
              ("\\[.* day.*\\]" ; urgent todo items
               (0 'helios/font/exclamation t))))
      (setq font-lock-defaults '(helios-thread-font-lock))
      (font-lock-mode 1)

      ;; enable line wrapping, mixed pitch mode
      (visual-line-mode t)
      (mixed-pitch-mode 1)
      ;; set line spacing and window margins
      (setq-local line-spacing 8)
      (set-window-margins (selected-window) 4 4)
      ;; press q to return to dashboard
      (evil-local-set-key 'normal (kbd "q") #'helios/dashboard)

      ;; enable jumping forward/backward between days with arrow keys
      ;; in main thread
      (when (string= buffer-name "thread/main")
        (evil-local-set-key 'normal (kbd "<")
                            `(lambda ()
                               (interactive)
                               (when (re-search-forward "@\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\).*" nil t)
                                 (recenter 0))))
        (evil-local-set-key 'normal (kbd ">")
                            `(lambda ()
                               (interactive)
                               (when (re-search-backward "@\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\).*" nil t)
                                 (recenter 0)))))
      ;; in recall threads
      (when (string-match "\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\).*" buffer-name)
        (evil-local-set-key 'normal (kbd "<")
                            `(lambda ()
                               (interactive)
                               (helios/recall/thread/navigate ,buffer-name)))
        (evil-local-set-key 'normal (kbd ">")
                            `(lambda ()
                               (interactive)
                               (helios/recall/thread/navigate ,buffer-name t)))
        ;; also set b key to go back to list of recall days
        (evil-local-set-key 'normal (kbd "b")
                            (lambda ()
                              (interactive)
                              (funcall 'helios/buffer/spawn "recall" #'helios/recall/view))))

      ;; jump to main thread instance in other threads with enter key
      (when (string-match "thread/" buffer-name)
        (evil-local-set-key 'normal (kbd "RET")
                            (lambda ()
                              (interactive)
                              ;; get current line and trim it
                              (let ((line (string-trim (thing-at-point 'line t))))
                                ;; spawn main thread and switch to it
                                (helios/buffer/spawn "thread/main" #'helios/thread/content (assoc "main" helios/threads))
                                (switch-to-buffer "*helios/thread/main*")
                                ;; search for line and jump to it
                                (when (search-forward line nil t)
                                  (recenter 0)))))))))

(defun helios/buffer/hook ()
  "helios buffer hook"
  ;; check when current buffer is helios dashboard and use header/mode lines as top/bottom padding
  (when (string-equal (buffer-name) "*helios*")
    ;; empty header line, set background color to match background and jack up height
    (setq-local header-line-format '(" "))
    (custom-set-faces
     '(header-line ((t (:background "#18131B" :foreground "#18131B"))))
     '(header-line-inactive ((t (:background "#18131B" :foreground "#18131B")))))
    (face-remap-add-relative 'header-line '((:height 1300)))
    ;; empty mode line, set background color to match background and jack up height
    (setq-local mode-line-format '(" "))
    (custom-set-faces
     '(mode-line ((t (:background "#18131B" :foreground "#18131B"))))
     '(mode-line-inactive ((t (:background "#18131B" :foreground "#18131B")))))
    (face-remap-add-relative 'mode-line '((:height 1300))))

  ;; reset mode/header lines if current buffer isn't helios dashboard
  (unless (string-equal (buffer-name) "*helios*")
    (custom-set-faces
     '(mode-line ((t (:inherit mode-line))))
     '(mode-line-inactive ((t (:inherit mode-line-inactive))))
     '(header-line ((t nil)))))

  ;; enable helios minor mode in all helios buffers
  (if (string-match "^\*helios" (buffer-name))
      (helios-mode 1)
    (helios-mode -1)))
#+end_src

threads
#+begin_src emacs-lisp :tangle ~/helios/threads.el
(defun helios/threads/add (thread-name item)
  "add to helios thread"
  ;; get thread list
  (let ((thread (assoc thread-name helios/threads)))
    (if thread
        ;; append to thread if already existing
        (setcdr thread (cons item (cdr thread)))
      ;; or create new thread
      (push (list thread-name item) helios/threads))))

(defun helios/thread/content (thread)
  "render content for individual helios thread buffers"
  (dolist (element (cdr thread))
    ;; insert single lines double spaced
    (when (stringp element)
      (insert element)
      (insert "\n\n"))
    ;; loop over chunks
    (when (listp element)
      ;; first element is the optional description
      (when (not (string-empty-p (car (last element))))
        ;; insert chunk description with font
        (insert (propertize (car (last element)) 'font-lock-face 'helios/font/chunk-description))
        (insert "\n"))
      ;; loop over chunk contents and insert, single spaced
      (dolist (line (reverse (butlast element)))
        (insert line)
        (insert "\n"))
      ;; pad newline at end
      (insert "\n"))))

(defun helios/threads/view ()
  "helios threads view"
  (insert (propertize "threads\n" 'font-lock-face 'helios/font/h2))
  ;; loop over threads and insert with keybind letter highlighted
  (mapcar (lambda (pair)
            (let* ((word (car pair))
                   (letter (cdr pair))
                   (match (string-match (regexp-quote letter) word 0)))
              (insert (substring word 0 (match-beginning 0)))
              (insert (propertize letter 'font-lock-face 'helios/font/emphasis))
              (insert (substring word (match-end 0)))
              (insert "\n")))
          helios/threadkeys)
  ;; switch to buffer and bind the keys
  (switch-to-buffer (current-buffer))
  (helios/threads/binds/map))

(defun helios/threads/binds/generate ()
  "find unique keys for threads"
  ;; use a hash table for efficiency
  (let ((used-letters (make-hash-table))
        result)
    ;; loop in reverse to maintain stability because threads are from most recent first
    (dolist (thread (reverse helios/threads))
      ;; loop over chracters to find when they are a letter and not already used
      ;; or if no options are available, pick the first available letter in alphabet
      (let* ((name (car thread))
             (unique-letter (or (cl-loop for char across name
                                         when (and (cl-position char "abcdefghijklmnopqrstuvwxyz")
                                                   (not (gethash (downcase char) used-letters)))
                                         return (downcase char))
                                (cl-loop for char across "abcdefghijklmnopqrstuvwxyz"
                                         unless (gethash char used-letters)
                                         return char))))
        ;; update hash table and results list
        (when unique-letter
          (puthash unique-letter t used-letters)
          ;; convert from char to string
          (push (cons name (string unique-letter)) result))))
    (setq helios/threadkeys result)))

(defun helios/threads/binds/map ()
  "generate keybinds for helios threads"
  ;; loop over threadkeys
  (dolist (pair helios/threadkeys)
    ;; get name and unique letter of thread
    ;; and then get the thread itself
    (let* ((name (car pair))
           (letter (cdr pair))
           (thread (assoc name helios/threads)))
      ;; bind the letter key to a lambda function that spawns the thread buffer
      (evil-local-set-key 'normal (kbd letter)
                          `(lambda ()
                             (interactive)
                             (helios/buffer/spawn (concat "thread/" (car ',thread)) #'helios/thread/content ',thread))))))
#+end_src

recall
#+begin_src emacs-lisp :tangle ~/helios/recall.el
(defun helios/recall/view ()
  "helios recall view"
  (insert (propertize "recall\n" 'font-lock-face 'helios/font/h2))
  ;; loop over recalls
  (dolist (entry (cdr (assoc "recall" helios/threads)))
    ;; insert without leading @
    (insert (substring (car (last entry)) 1))
    (insert "\n"))
  ;; switch to buffer and bind enter key for selections
  (switch-to-buffer (current-buffer))
  (evil-local-set-key 'normal (kbd "RET") #'helios/recall/thread/spawn))

(defun helios/recall/thread/spawn ()
  "spawn thread buffer for individual recall days"
  (interactive)
  ;; get the line the cursor is on and strip newline
  (let ((line (thing-at-point 'line t)))
    (setq line (replace-regexp-in-string "\n" "" line))
    ;; make sure the line isn't blank
    (unless (string-empty-p line)
      (dolist (entry (assoc "main" helios/threads))
        ;; spawn recall thread buffer if it is the right date
        (when (listp entry)
          (if (string-match (concat ".*@" line ".*") (car (last entry)))
              (helios/buffer/spawn line #'helios/recall/thread/content entry)))))))

(defun helios/recall/thread/content (current)
  "render content for individual recall day thread buffers"
  (let ((day-start-flag nil)
        (day-contents '()))
    ;; loop to get entries from the specified day
    (dolist (entry (assoc "main" helios/threads))
      ;; on the target day
      (when day-start-flag
        ;; entry is a chunk
        (when (listp entry)
          ;; a new recall marks end of day
          (if (string-match-p "@" (car (last entry)))
              (setq day-start-flag nil)
            ;; otherwise push entries
            (push entry day-contents)))
        ;; entry is a string
        (when (stringp entry)
          (push entry day-contents)))

      ;; find target date
      (when (listp entry)
        (if (equal entry current)
            (setq day-start-flag t))))

    ;; render contents of day
    (dolist (entry day-contents)
      ;; chunks
      (when (listp entry)
        ;; insert chunk description if needed
        (when (not (string-empty-p (car (last entry))))
          (insert (propertize (car (last entry)) 'font-lock-face 'helios/font/chunk-description))
          (insert "\n"))
        ;; insert chunk contents
        (dolist (item (reverse (butlast entry)))
          (insert item)
          (insert "\n"))
        ;; insert padding
        (insert "\n"))

      ;; lines
      (when (stringp entry)
        ;; insert double spaced
        (insert entry)
        (insert "\n\n"))))

  ;; render recall
  (dolist (line (reverse current))
    (insert line)
    (insert "\n")))

(defun helios/recall/thread/navigate (current-day &optional direction)
  "navigate between helios recall threads"
  ;; init found flag and get recalls
  (let ((found nil)
        (recall (cdr (assoc "recall" helios/threads))))
    ;; reverse if going forwards in time with >
    (if direction
        (setq recall (reverse recall)))
    ;; loop through recalls
    (dolist (entry recall)
      ;; this is the next/previous day, depending on direction
      (when found
        ;; reset flag
        (setq found nil)
        ;; spawn recall thread using date without @ for buffer name
        (helios/buffer/spawn (substring (car (last entry)) 1) #'helios/recall/thread/content entry))
      ;; set flag when at current day
      (when (string-match-p (regexp-quote current-day) (car (last entry)))
        (setq found t)))))
#+end_src

todo
#+begin_src emacs-lisp :tangle ~/helios/todo.el
(defun helios/todo/view ()
  "helios todo view"
  (insert (propertize "todo\n" 'font-lock-face 'helios/font/h2))
  (let ((completed '()))
    ;; loop over todos and save them for later if they are completed or insert into buffer if not
    (dolist (todo helios/todo)
      (if (string= "x" (cdr todo))
          (push (car todo) completed)
        (if (string-empty-p (cdr todo))
            (insert (format "• %s\n" (car todo)))
          (insert (format "• %s [%s]\n" (car todo) (cdr todo))))))

    ;; render completed heading if there are completed todos
    (if (> (length completed) 0)
        (insert (propertize "\ncompleted\n" 'font-lock-face 'helios/font/h4)))
    ;; loop and insert the completed todos in, greyed out
    (dolist (todo completed)
      (insert (propertize (format "• %s\n" todo) 'font-lock-face 'helios/font/inactive)))))

(defun helios/todo/sort ()
  "sort helios todos"
  (let ((upcoming '())
        (urgent '())
        (others '()))
    (dolist (todo helios/todo)
      ;; test if date deadline is set
      (if (string-match "\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\)" (cdr todo))
          ;; extract separator (. or /) and parse date and calculate days until then
          (let* ((date (helios/utility/parse-date (cdr todo)))
                 (days-between (- (calendar-absolute-from-gregorian date)
                                  (calendar-absolute-from-gregorian (calendar-current-date)))))
            ;; upcoming items are in the next 10 days
            (if (< days-between 11)
                (progn
                  ;; change the deadline component to the number of days remaining
                  ;; make sure the grammar matches plural/singular
                  (if (= days-between 1)
                      (setcdr todo (format "%d day" days-between))
                    (setcdr todo (format "%d days" days-between)))
                  (push todo upcoming))
              ;; not urgent so don't do anything... yet
              (push todo others)))
        ;; also push to urgent if todo contains !!
        ;; otherwise push to others
        (if (string-match ".*!!.*" (car todo))
            (push todo urgent)
          (push todo others))))
    ;; reconstruct todo list with urgent items in front
    (setq helios/todo (append (nreverse urgent) (nreverse upcoming) (nreverse others)))))
#+end_src

calendar
#+begin_src emacs-lisp :tangle ~/helios/calendar.el
(defun helios/calendar/view ()
  "helios calendar view"
  (setq helios/calendar/date (calendar-current-date))
  ;; display calendar in gui with svg
  (if (display-graphic-p)
      (helios/calendar/svg #'helios/calendar/svg/month)
    ;; display calendar in tui with ascii
    (helios/calendar/text)))

(defun helios/calendar/svg (content-function &optional args)
  "render calendar in svg"
  (let ((svg)
        (inhibit-read-only t)
        (inhibit-message t))
    ;; render svg content using content function
    ;; call with arguments if passed
    (if args
        (setq svg (funcall content-function args))
      (setq svg (funcall content-function)))

    ;; setup and display svg
    (erase-buffer)
    (insert "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
    (svg-print svg)
    ;; only call image-mode if not already enabled, or else it outlines svg
    (unless (eq major-mode 'image-mode)
      (image-mode))
    (image-transform-set-scale 1)
    (helios/buffer/hook)

    ;; bind monthly view
    (evil-local-set-key 'normal (kbd "m")
                        `(lambda ()
                           (interactive)
                           (funcall 'helios/calendar/svg #'helios/calendar/svg/month)))
    ;; bind weekly view
    (evil-local-set-key 'normal (kbd "w")
                        `(lambda ()
                           (interactive)
                           (funcall 'helios/calendar/svg #'helios/calendar/svg/week)))
    ;; bind daily view
    (evil-local-set-key 'normal (kbd "d")
                        `(lambda ()
                           (interactive)
                           (funcall 'helios/calendar/svg #'helios/calendar/svg/day)))
    ;; enable navigation using arrow keys
    (evil-local-set-key 'normal (kbd "<")
                        `(lambda ()
                           (interactive)
                           (helios/calendar/navigate)))
    (evil-local-set-key 'normal (kbd ">")
                        `(lambda ()
                           (interactive)
                           (helios/calendar/navigate t)))))

(defun helios/calendar/svg/month (&optional date-arg)
  "render helios calendar monthly view"
  ;; update period to monthly
  (setq helios/calendar/period 'month)
  ;; set dimensions and create svg
  (let* ((cell-width 198)
         (cell-height 160)
         (cell-max-lines 5)
         (svg (svg-create 1500 1000))
         ;; use default date if no argument was passed
         (date (if date-arg date-arg helios/calendar/date))
         ;; get calendar data and calculate
         (month (calendar-extract-month date))
         (year (calendar-extract-year date))
         (last-day (calendar-last-day-of-month month year))
         (first-weekday (calendar-day-of-week (list month 1 year)))
         (weeks-in-month (ceiling (/ (+ last-day first-weekday) 7.0))))

    ;; render month and year header
    (svg-text svg
              (format "%s %d" (calendar-month-name month) year)
              :x (/ 1400 2)
              :y 30
              :fill "#b4f9f8"
              :font-family "Yrsa, serif"
              :font-size 30
              :font-weight "bold"
              :text-anchor "middle")

    ;; render weekday titles
    (let ((day-names '("Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday")))
      (dotimes (i 7)
        (svg-text svg
                  (nth i day-names)
                  :x (+ (/ cell-width 2) 20 (* i cell-width))
                  :y 60
                  :font-family "Yrsa, serif"
                  :font-size 18
                  :fill "#bb9af7"
                  :text-anchor "middle")))

    ;; resize cells and reduce line count when necessary
    (when (> weeks-in-month 5)
      (setq cell-height 135)
      (setq cell-max-lines 4))

    ;; render calendar grid
    (dotimes (row weeks-in-month)
      (dotimes (col 7)
        (svg-rectangle svg
                       (+ 20 (* col cell-width))
                       (+ 70 (* row cell-height))
                       cell-width
                       cell-height
                       :fill "#18131A"
                       :stroke "#a9b1d6")))

    ;; render days of month
    (let ((day 1))
      ;; loop over each day of each week
      (dotimes (i (* 7 weeks-in-month))
        ;; make sure day is in bounds of month
        (when (and (>= i first-weekday) (<= day last-day))
          ;; calculate coordinates and keep track of starting y position
          (let* ((x (+ 25 (* (mod i 7) cell-width)))
                 (y (+ 90 (* (/ i 7) cell-height)))
                 (start-y y)
                 ;; keep track of line count to prevent overflow
                 (line-count 0)
                 ;; store date as list, corner number font color, and result of wrapping calls
                 (date-list (list month day year))
                 (day-color "#a9b1d6")
                 (result))

            ;; allow space for day number in corner
            (setq y (+ 20 y))

            ;; loop over all calendar events
            (dolist (event (reverse helios/events))
              ;; check if event falls on current day
              (when (equal date-list (car event))
                ;; don't overflow cell
                (when (< line-count cell-max-lines)
                  ;; change color if todo
                  (let ((color "#a9b1d6"))
                    ;; use assoc to check if event is a todo task
                    (if (assoc (cdr event) helios/todo)
                        (setq color "#7aa2f7"))
                    ;; render with wrapped line breaks
                    (setq result (helios/calendar/svg/wrapped-text (cdr event)
                                                                   ;; pass in allowance of remaining lines
                                                                   24 (- cell-max-lines line-count)
                                                                   x y
                                                                   16 color)))
                  ;; keep track of next available y-coordinate after rendering
                  (setq y (car result))
                  ;; as well as updated line count
                  (setq line-count (+ line-count (cdr result)))
                  ;; pad events slightly
                  (setq y (+ 7 y)))))

            ;; change color of current day in corner
            (if (= day (nth 1 date))
                (setq day-color "#e0af68"))
            ;; another color if overflowed
            (if (>= line-count cell-max-lines)
                (setq day-color "#b4f9f8"))
            ;; render day number in corner
            (svg-text svg
                      (number-to-string day)
                      :x x
                      :y start-y
                      :fill day-color
                      :font-family "Yrsa, serif"
                      :font-size 18)

            ;; onto the next day
            (setq day (+ day 1))))))
    ;; return svg
    svg))

(defun helios/calendar/svg/week (&optional date-arg)
  "render helios calendar weekly view"
  ;; update period to weekly
  (setq helios/calendar/period 'week)
  ;; set dimensions and create svg
  (let* ((cell-width 198)
         (cell-height 800)
         (svg (svg-create 1500 1000))
         ;; set the date, using either the argument or last date
         (date (if date-arg date-arg helios/calendar/date))
         ;; get day of week and calculate week start and end
         (day-of-week (calendar-day-of-week date))
         (week-start (calendar-gregorian-from-absolute
                      (- (calendar-absolute-from-gregorian date)
                         (mod (- day-of-week calendar-week-start-day) 7))))
         (week-end (calendar-gregorian-from-absolute
                    (+ (calendar-absolute-from-gregorian week-start) 6))))

    ;; render week header with month and year
    (svg-text svg
              (format "Week of %s %d, %d"
                      (calendar-month-name (car week-start))
                      (cadr week-start)
                      (caddr week-start))
              :x (/ 1400 2)
              :y 30
              :fill "#b4f9f8"
              :font-family "Yrsa, serif"
              :font-size 25
              :font-weight "bold"
              :text-anchor "middle")

    ;; render weekday titles, grid, and also border box at top around date
    (let ((day-names '("Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday")))
      (dotimes (i 7)
        (svg-text svg
                  (nth i day-names)
                  :x (+ (/ cell-width 2) 20 (* i cell-width))
                  :y 60
                  :font-family "Yrsa, serif"
                  :font-size 18
                  :fill "#bb9af7"
                  :text-anchor "middle")
        (svg-rectangle svg
                       (+ 20 (* i cell-width))
                       70
                       cell-width
                       cell-height
                       :fill "#18131A"
                       :stroke "#a9b1d6")
        (svg-rectangle svg
                       (+ 20 (* i cell-width))
                       70
                       cell-width
                       30
                       :fill "#18131A"
                       :stroke "#a9b1d6")))

    ;; render days of the week
    (let ((current-date week-start))
      ;; loop over each day of week
      (dotimes (i 7)
        ;; calculate coordinates and filter out events from the day
        (let ((x (+ 30 (* i cell-width)))
              (y 90)
              (events (seq-filter (lambda (event) (equal (car event) current-date)) helios/events)))
          ;; render month/day centered in box
          (svg-text svg
                    (format "%d/%d" (car current-date) (cadr current-date))
                    :x (+ (/ cell-width 2) (* i cell-width))
                    :y y
                    :font-family "Yrsa, serif"
                    :font-size 18)
          (setq y (+ 30 y))

          ;; order events sorted by time
          (setq events (helios/calendar/order-events events))

          ;; render events of the day
          (dolist (event events)
            ;; change color if todo by using assoc to search todo cons cells
            (let ((color "#a9b1d6"))
              (if (assoc (cdr event) helios/todo)
                  (setq color "#7aa2f7"))
              ;; render with wrapped line breaks and update returned y-coordinate, the car component
              (setq y (car (helios/calendar/svg/wrapped-text (cdr event)
                                                             24 10
                                                             x y
                                                             17 color))))
            (setq y (+ 15 y)))

          ;; move to next day
          (setq current-date (calendar-gregorian-from-absolute
                              (+ (calendar-absolute-from-gregorian current-date) 1))))))
    ;; return svg
    svg))

(defun helios/calendar/svg/day (&optional date-arg)
  "render helios calendar daily view"
  ;; update period to daily
  (setq helios/calendar/period 'day)
  ;; set dimensions and create svg
  (let* ((cell-width 435)
         (cell-height 800)
         (svg (svg-create 1500 1000))
         ;; track coordinates
         (x 35)
         (y 30)
         ;; set the date, using either the argument or last date
         (date (if date-arg date-arg helios/calendar/date))
         ;; filter out events
         (events (seq-filter (lambda (event) (equal (car event) date)) helios/events))
         ;; grab date's timeblocks and init variables
         (blocks (assoc date helios/timeblocks))
         (sorted-blocks '())
         (timeblock-fill (if blocks "#211c29" "#18131A"))
         (labels '("events" "todo" "timeblocks"))
         (todos '()))

    ;; render date header
    (svg-text svg
              (format "%d.%d.%d"
                      (car date)
                      (cadr date)
                      (caddr date))
              :x (/ 1400 2)
              :y y
              :fill "#b4f9f8"
              :font-family "Yrsa, serif"
              :font-size 25
              :font-weight "bold"
              :text-anchor "middle")
    (setq y (+ y 30))

    ;; render boxes and their respective labels
    (dotimes (i 3)
      (svg-text svg
                (nth i labels)
                :x (+ 20 (/ cell-width 2) (* i cell-width) (* i 45))
                :y y
                :font-family "Yrsa, serif"
                :font-size 19
                :fill "#bb9af7"
                :text-anchor "middle")
      (svg-rectangle svg
                     (+ 20 (* i cell-width) (* i 45))
                     (+ y 10)
                     cell-width
                     cell-height
                     :fill (if (= i 2) timeblock-fill "#18131A")
                     :stroke "#a9b1d6"))
    (setq y (+ y 40))

    ;; order events sorted by time
    (setq events (helios/calendar/order-events events))

    ;; render events of the day
    (let ((y y))
      (dolist (event events)
        ;; set aside todos
        (if (assoc (cdr event) helios/todo)
            (push event todos)
          ;; render with wrapped line breaks and update local coordinate
          (progn
            (setq y (car (helios/calendar/svg/wrapped-text (cdr event)
                                                           45 50
                                                           x y
                                                           20 "#a9b1d6")))
            (setq y (+ 15 y))))))

    ;; render todos
    (let ((y y))
      (dolist (todo todos)
        ;; render with wrapped line breaks and update local coordinate
        (setq y (car (helios/calendar/svg/wrapped-text (cdr todo)
                                                       45 50
                                                       (+ x cell-width 45) y
                                                       20 "#a9b1d6")))
        (setq y (+ 15 y))))

    ;; render timeblocks if defined
    (when blocks
      ;; sort timeblocks
      (setq sorted-blocks
            (sort (cdr blocks)
                  (lambda (a b)
                    ;; compare starting times of blocks
                    (< (helios/utility/to-military-time (caar a))
                       (helios/utility/to-military-time (caar b))))))

      ;; calculate start and end of timeblocked day
      (let* ((day-start (caaar sorted-blocks))
             (day-end (cdaar (last sorted-blocks)))
             ;; convert to military time
             (day-start-military (helios/utility/to-military-time day-start))
             (day-end-military (helios/utility/to-military-time day-end))
             ;; calculate the length of time and block unit in allocated rectangle
             (day-length (- day-end-military day-start-military))
             ;; block units are used to proportionally size blocks
             (block-unit (/ (float cell-height) day-length))
             ;; compensate local y-coordinate
             (y (- y 30)))
        ;; loop through blocks
        (dolist (block sorted-blocks)
          ;; extract times - start and end - and event
          (let* ((times (car block))
                 (start-time (car times))
                 (end-time (cdr times))
                 (event (cdr block))
                 ;; convert to military time
                 (start-time-military (helios/utility/to-military-time start-time))
                 (end-time-military (helios/utility/to-military-time end-time))
                 ;; convert military times to strings
                 (start-time-military-string (number-to-string start-time-military))
                 (end-time-military-string (number-to-string end-time-military))
                 ;; calculate duration of block
                 (duration (- end-time-military start-time-military)))
            ;; draw block
            (svg-rectangle svg
                           (+ 20 (* 45 2) (* cell-width 2))
                           ;; calculate offset from top of box
                           ;; by finding time elapsed since start of timeblocked day
                           ;; then use block units to translate into proportional svg units
                           (+ y (* (- start-time-military day-start-military) block-unit))
                           cell-width
                           ;; calculate relative height of block
                           (* duration block-unit)
                           :fill "#18131A"
                           :stroke "#a9b1d6")
            ;; draw label text
            (svg-text svg
                      ;; format neatly - minutes need 2 digits for leading 0s
                      (format "[%d:%02d-%d:%02d] %s"
                              (car start-time) (cdr start-time)
                              (car end-time) (cdr end-time)
                              event)
                      ;; center text horizontally
                      :x (+ 20 (* 45 2) (* cell-width 2) (/ cell-width 2))
                      ;; center text vertically
                      :y (+ y
                            ;; place in corresponding block
                            (* (- start-time-military day-start-military) block-unit)
                            ;; pad to center of block
                            (* block-unit (/ duration 2))
                            5)
                      :font-family "Yrsa, serif"
                      :font-size 20
                      :text-anchor "middle")))))
    ;; return svg
    svg))

(defun helios/calendar/svg/wrapped-text (str limit allowance x y font-size color)
  "render svg text with wrapped line breaks"
  ;; split words by space, init variables, and keep track of y-coordinate and line count
  (let ((words (split-string str))
        (line "")
        (lines '())
        (line-y y)
        (line-count 0))
    ;; go word by word and split by the specified character limit
    (dolist (word words)
      ;; reset if new word would push over limit
      (when (>= (+ (length line) (length word)) limit)
        (push line lines)
        (setq line ""))
      ;; append word onto line
      (setq line (concat line " " word)))

    ;; don't forget stragglers that never got pushed
    (if (not (string-empty-p line))
        (push line lines))

    ;; loop through chopped up lines to render
    (dolist (line (reverse lines))
      ;; don't exceed line allowance
      (when (< line-count allowance)
        ;; add .. at end if cutting off
        (if (= line-count (- allowance 1))
            (setq line (concat line "..")))
        ;; render line
        (svg-text svg
                  line
                  :x x
                  :y line-y
                  :font-family "Yrsa, serif"
                  :font-size font-size
                  :fill color)
        ;; update y-coordinate with line height padding
        (setq line-y (+ line-y 18)))
      ;; always update line count to relay overflow status
      (setq line-count (+ line-count 1)))
    ;; return updated y-coordinate so other events aren't rendered right on top
    ;; and line count as well in cons cell format
    (cons line-y line-count)))

(defun helios/calendar/ascii ()
  "render calendar in ascii"
  (insert "calendar"))

(defun helios/calendar/navigate (&optional direction)
  "navigate in helios calendar"
  ;; get calendar data and calculate the number of days in the month
  (let* ((month (calendar-extract-month helios/calendar/date))
         (day (calendar-extract-day helios/calendar/date))
         (year (calendar-extract-year helios/calendar/date))
         (days-in-month (calendar-last-day-of-month month year))
         ;; calculate next and previous year
         (prev-year (- year 1))
         (next-year (+ year 1))
         ;; month-wise navigation
         (prev-month (if (= month 1) 12 (- month 1)))
         (next-month (if (= month 12) 1 (+ month 1)))
         (prev-month-year (if (= month 1) prev-year year))
         (next-month-year (if (= month 12) next-year year))
         ;; week-wise navigation
         (prev-week-day (- day 7))
         (next-week-day (+ day 7))
         (prev-week-month month)
         (next-week-month month)
         (prev-week-year year)
         (next-week-year year)
         ;; build a new date
         (new-date '())
         ;; content-function determines which view to progress to
         (content-function))

    ;; navigate between months
    (when (eq helios/calendar/period 'month)
      ;; create new date in correct direction of navigation
      (if direction
          (setq new-date (list next-month 1 next-month-year))
        (setq new-date (list prev-month 1 prev-month-year)))
      ;; set svg monthly view as content function
      (setq content-function #'helios/calendar/svg/month))

    ;; navigate between weeks
    (when (eq helios/calendar/period 'week)
      ;; fork flow of time
      (if direction
          (progn
            ;; check overflow
            (when (> next-week-day days-in-month)
              ;; rubber-band to next month
              (setq next-week-day (- next-week-day days-in-month))
              (setq next-week-month next-month)
              ;; update year if necessary
              (setq next-week-year (if (= next-week-month 1) next-year year)))
            ;; construct new date
            (setq new-date (list next-week-month next-week-day next-week-year)))
        (progn
          ;; check overflow
          (when (< prev-week-day 1)
            ;; rubber-band to previous month
            (setq prev-week-day (+ prev-week-day (calendar-last-day-of-month prev-week-month prev-week-year)))
            (setq prev-week-month prev-month)
            ;; update year if necessary
            (setq prev-week-year (if (= prev-week-month 12) prev-year year)))
          ;; construct new date
          (setq new-date (list prev-week-month prev-week-day prev-week-year))))
      ;; set svg weekly view as content function
      (setq content-function #'helios/calendar/svg/week))

    ;; navigate between days
    (when (eq helios/calendar/period 'day)
      (if direction
          ;; going forward - rubber-band forward or simply increment day value
          (if (= day days-in-month)
              (setq new-date (list next-month 1 next-month-year))
            (setq new-date (list month (+ day 1) year)))
        ;; going backward - rubber-band backward or simply decrement day value
        (if (= day 1)
            (let ((prev-month-days (calendar-last-day-of-month prev-month prev-month-year)))
              (setq new-date (list prev-month prev-month-days prev-month-year)))
          (setq new-date (list month (- day 1) year))))
      ;; set svg daily view as content function
      (setq content-function #'helios/calendar/svg/day))

    ;; update new date
    (setq helios/calendar/date new-date)

    ;; call svg rendering function with content function and new date
    (helios/calendar/svg content-function new-date)))

(defun helios/calendar/order-events (events)
  "sort events by time"
  ;; in sort, a is the first item and b is the second item
  ;; t means a comes before b
  ;; nil means b comes before a
  (sort events
        (lambda (a b)
          ;; attempt to parse out times
          (let ((parsed-a (helios/utility/parse-time (cdr a)))
                (parsed-b (helios/utility/parse-time (cdr b))))
            (cond
             ;; order two times compared in military format
             ((and parsed-a parsed-b)
              (< (helios/utility/to-military-time parsed-a)
                 (helios/utility/to-military-time parsed-b)))
             ;; a contains a time and b doesn't, so a comes first
             (parsed-a
              t)
             ;; b contains a time and a doesn't, so b comes first
             (parsed-b
              nil)
             ;; neither a and b contain times
             ;; unstable sort - a will always come first in these cases
             (t t))))))
#+end_src

utilities
#+begin_src emacs-lisp :tangle ~/helios/utilities.el
(defun helios/utility/parse-date (str)
  "parse date string"
  (if (string-match "\\([0-9]+\\([/.]\\)[0-9]+\\2[0-9]+\\)" str)
      ;; extract date string and separator from regex test
      (let* ((date-string (match-string 1 str))
             (separator (match-string 2 str))
             ;; split date string by separator
             (parts (mapcar #'string-to-number (split-string date-string (regexp-quote separator))))
             ;; extract month and day
             (month (nth 0 parts))
             (day (nth 1 parts))
             ;; extract year
             (year (nth 2 parts))
             ;; reconstruct into date list
             (date (list month day year))
             ;; get today's date
             (today (calendar-current-date)))
        ;; turn YY year format into YYYY by just adding 2000 and update date list
        (when (< year 100)
          (setq year (+ 2000 year))
          (setq date (list month day year)))
        ;; return date parsed as (month day year)
        date)
    (message "[helios] invalid date: %s" str)))

(defun helios/utility/parse-time (str)
  "parse time string"
  (if (string-match "\\([0-9]+\\):\\([0-9]+\\)" str)
      ;; extract hour and minute values from regex test and convert to integers
      (let* ((hour-string (match-string 1 str))
             (minute-string (match-string 2 str))
             (hour (string-to-number hour-string))
             (minute (string-to-number minute-string)))
        ;; return cons cell if valid time
        (if (and (<= 0 hour 23) (<= 0 minute 59))
            (cons hour minute)
          (message "[helios] invalid time: %s" str)))
    ;; no time found
    nil))

(defun helios/utility/to-military-time (time)
  "convert time to military time"
  ;; convert hour and minute values to strings
  (let ((hour-string (number-to-string (car time)))
        (minute-string (number-to-string (cdr time))))
    ;; add leading 0 to minutes if necessary
    (if (= (length minute-string) 1)
        (setq minute-string (concat "0" minute-string)))
    ;; concatenate and convert back to integer
    (string-to-number (concat hour-string minute-string))))

(defun helios/utility/minutes-before (time n)
  "calculate time n minutes before"
  (let ((minutes-before (cons (car time) (- (cdr time) n))))
    ;; adjust for rubber-banding
    (when (< (cdr minutes-before) 0)
      (setcdr minutes-before (+ 60 (cdr minutes-before)))
      (setcar minutes-before (- (car minutes-before) 1)))
    minutes-before))

(defun helios/utility/neutralize-mouse ()
  "neutralize mouse"
  (define-key evil-motion-state-local-map [down-mouse-1] #'ignore)
  (define-key evil-motion-state-local-map [mouse-1] #'ignore)
  (define-key evil-motion-state-local-map [drag-mouse-1] #'ignore)
  (define-key evil-motion-state-local-map [double-mouse-1] #'ignore)
  (define-key evil-motion-state-local-map [triple-mouse-1] #'ignore)
  (define-key evil-motion-state-local-map [mouse-2] #'ignore)
  (define-key evil-motion-state-local-map [mouse-3] #'ignore)
  (define-key evil-motion-state-local-map [wheel-up] #'ignore)
  (define-key evil-motion-state-local-map [wheel-down] #'ignore))

(defun helios/utility/schedule-notifications ()
  "schedule notifications"
  ;; cancel previously set timers and reset
  (dolist (timer helios/timers)
    (cancel-timer timer))
  (setq helios/timers '())

  ;; get current time
  (let* ((now (decode-time))
         (current-time (cons (nth 2 now) (nth 1 now))))
    ;; loop over queued notifications
    (dolist (notification helios/notifications)
      ;; extract time and message components
      (let ((time (car notification))
            (message (cdr notification)))
        ;; only schedule if time has not passed
        (if (and (>= (car time) (car current-time)) (> (cdr time) (cdr current-time)))
            ;; schedule at specified time with no repetition using notify utility
            ;; store returned timer object
            (push (run-at-time (format "%d:%02d" (car time) (cdr time)) nil `(lambda () (helios/utility/notify ,message)))
                  helios/timers))))))

(defun helios/utility/notify (message)
  "send notification"
  ;; macos - use applescript
  (when (eq system-type 'darwin)
    (start-process
     "helios-notify" ; process name
     nil             ; no output buffer
     "osascript"
     "-e"
     (format "display dialog \"%s\" with title \"helios\" buttons {\"ok\"}" message))))

(defun helios/utility/watchdog ()
  "keep helios file up-to-date"
  ;; watch file for changes and reload
  (file-notify-add-watch
   helios/file
   '(change)
   (lambda (event)
     ;; delay to let filesystem catch up
     (run-with-timer 0.5 nil
                     (lambda (action)
                       ;; restart the watcher if stopped
                       (if (eq action 'stopped)
                           (helios/utility/watchdog)
                         ;; otherwise load file
                         (helios/load-file)))
                     ;; pass in the change action
                     (cadr event))))
  (message "[helios] watchdog watching"))

(defun helios/utility/backup ()
  "back up helios"
  ;; format the last datetime known to helios
  (let* ((date-string (format-time-string "%m-%d-%Y" helios/current-time))
         ;; get backup path
         (backup-folder "~/helios/backups")
         (backup-file (expand-file-name (concat date-string ".nyx") backup-folder)))
    ;; make backup folder if it doesn't exist
    (unless (file-directory-p backup-folder)
      (make-directory backup-folder t))
    ;; copy over and log
    (copy-file helios/file backup-file t)
    (message "[helios] backed up %s" (concat date-string ".nyx"))))
#+end_src

** init.el
#+begin_src emacs-lisp :tangle ~/.config/doom/init.el :mkdirp yes
;; -*- lexical-binding: t; -*-
(doom! :input

       :completion company ivy

       :ui doom (emoji +unicode) hl-todo modeline ophints
           (popup +defaults) (vc-gutter +pretty) vi-tilde-fringe workspaces zen

       :editor (evil +everywhere) file-templates fold snippets word-wrap

       :emacs dired electric undo vc

       :term eshell shell term vterm

       :checkers syntax

       :tools biblio debugger docker ein (eval +overlay) lookup lsp
              magit make pdf tmux tree-sitter upload

       :os (:if IS-MAC macos) tty

       :lang (cc +lsp) common-lisp data emacs-lisp json javascript julia latex
             markdown ocaml org python (ruby +rails) (rust +lsp) sh web yaml

       :email

       :app calendar

       :config (default +bindings +smartparens))
#+end_src

** packages.el
#+begin_src emacs-lisp :tangle ~/.config/doom/packages.el
;; -*- no-byte-compile: t; -*-
(package! rainbow-mode)
(package! mixed-pitch)
(package! devdocs)
(package! olivetti)
#+end_src

** config.el
*** general settings
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
;; -*- lexical-binding: t; -*-
(setq doom-theme 'nyx
      doom-font (font-spec :family "Fira Code" :size 13 :height 1.0)
      doom-variable-pitch-font (font-spec :family "Yrsa")

      confirm-kill-emacs nil
      display-line-numbers-type 'relative

      comfy-modes '(org-mode devdocs-mode))

(setq-default indent-tabs-mode nil
              tab-width 4
              tab-stop-list ()
              indent-line-function 'insert-tab

              python-indent-guess-indent-offset nil
              python-indent-offset 4)

(push '(fullscreen . maximized) default-frame-alist)
#+end_src

helios
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(load-file "~/helios/helios.el")
(require 'helios)

;; load helios and start watchdog on startup
(add-hook 'emacs-startup-hook (lambda ()
                                ;; running after idle ensures all startup processes have completed
                                (run-with-idle-timer 0.5 nil
                                                     (lambda ()
                                                       (helios/load-file)
                                                       (helios/utility/watchdog)))))

;; back up helios every day
(run-at-time "23:59" 86400 #'helios/utility/backup)

;; reload helios every day at midnight
;; 24:00 indicates the next midnight, whereas 00:00 would indicate the passed midnight
;; repeat every 86400 seconds, which is exactly 24 hours
(run-at-time "24:00" 86400 #'helios/load-file)
#+end_src

mac specific settings
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(when (equal system-type 'darwin)
  ;; make command [⌘] => meta & option [⌥] => super
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'super))
#+end_src

popup rules
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(set-popup-rules!
  '(("^\\*doom:vterm" :side bottom :size 0.32)))
#+end_src

*** keymaps
misc.
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(map! :leader
      ;; selene keyspace
      "s s" #'(lambda () (interactive) (find-file "~/selene.org"))
      "s h" #'(lambda () (interactive) (find-file "~/helios.nyx"))
      "s o" #'olivetti-mode

      "v" #'+vterm/toggle
      "d" #'devdocs-lookup

      "r c" #'(lambda () (interactive) (selene/run-clang (buffer-file-name)))
      "r p" #'(lambda () (interactive) (selene/run-python (buffer-file-name)))

      "! l" #'flycheck-list-errors
      "! n" #'flycheck-next-error
      "! p" #'flycheck-previous-error

      "+" #'selene/anchor
      "@" #'helios/dashboard)
#+end_src

evil
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(define-key evil-motion-state-map (kbd "C-`") 'evil-emacs-state)
(define-key evil-emacs-state-map (kbd "C-`") 'evil-exit-emacs-state)
#+end_src

disable control-scroll zooming in accidentally
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(define-key global-map (kbd "<C-wheel-up>") #'ignore)
(define-key global-map (kbd "<C-wheel-down>") #'ignore)
#+end_src

*** functions
change hook
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(defun selene/on-change ()
  ;; ignore helios buffers
  (unless (string-match "^\*helios" (buffer-name))
    ;; comfy line height for comfy serif font
    (when (member major-mode comfy-modes)
      (mixed-pitch-mode 1)
      (setq-local line-spacing 6))
    (when (not (member major-mode comfy-modes))
      (mixed-pitch-mode -1)
      (setq-local line-spacing 6)))

  ;; check if .nyx file
  (when (buffer-file-name)
    (when (string= (file-name-extension (buffer-file-name)) "nyx")
      (mixed-pitch-mode 1)
      (setq-local line-spacing 6)
      (visual-line-mode t)
      (set-window-margins (selected-window) 4 4))
    (advice-add 'basic-save-buffer :after (lambda (_) (selene/on-change)))))
#+end_src

run programs in vterm
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(defun selene/run-clang (file-name)
  (interactive)
  (vterm)
  (set-buffer "*vterm*")
  (term-send-raw-string (concat "clang++ -std=c++11 \"" file-name "\" && ./a.out\n")))

(defun selene/run-python (file-name)
  (interactive)
  (vterm)
  (set-buffer "*vterm*")
  (term-send-raw-string (concat "python3 \"" file-name "\"\n")))
#+end_src

anchor
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(defvar selene/anchors '())
(defun selene/anchor ()
  "anchors"
  (interactive)
  ;; get the prefix key and use it to retrieve anchor
  ;; nil, which can be an assoc key, if no prefix
  (let* ((prefix current-prefix-arg)
         (anchor (assoc prefix selene/anchors)))
    (if anchor
        ;; return to anchor
        (progn
          (goto-char (cadr anchor))
          (setq selene/anchors (assq-delete-all prefix selene/anchors))
          (delete-overlay (cddr anchor)))
      ;; drop anchor
      (let ((highlight (make-overlay (line-beginning-position) (line-end-position))))
        (overlay-put highlight 'face '(:background "#1b2a4a"))
        (push (cons prefix (cons (point) highlight)) selene/anchors)))
    ;; log concisely
    (message "[anchor%s] %s to line %d"
             (if prefix (format "|%d" prefix) "")
             (if anchor "returned" "dropped")
             (line-number-at-pos (point)))))
#+end_src

*** hooks
on buffer list change
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(add-hook 'buffer-list-update-hook 'selene/on-change)
#+end_src

2 space tab in lisp modes
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(add-hook 'lisp-mode-hook (lambda () (setq-local tab-width 2)))
(add-hook 'emacs-lisp-mode-hook (lambda () (setq-local tab-width 2)))
#+end_src

fix issue of small variable-pitch text after new client frame
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(add-hook 'server-after-make-frame-hook
          (lambda ()
            (setq-local mixed-pitch-set-height t)
            (set-face-attribute 'variable-pitch nil :height 1.4)))
#+end_src

org mode code block fix parentheses mismatch
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(add-hook 'org-mode-hook
          (lambda ()
            (modify-syntax-entry ?< "." org-mode-syntax-table)
            (modify-syntax-entry ?> "." org-mode-syntax-table)))
#+end_src

misc.
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(remove-hook 'doom-first-input-hook #'evil-snipe-mode) ; evil s functionality
#+end_src

*** org
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(setq org-directory "~/org/")
(setq org-log-done 'time)
#+end_src

make org pretty
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(setq org-hide-emphasis-markers t)

(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

mixed-pitch for org
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(use-package! mixed-pitch
  :hook (org-mode . mixed-pitch-mode)
  :config
  (setq mixed-pitch-set-height t)
  (set-face-attribute 'variable-pitch nil :height 1.4))
#+end_src

org-capture
#+begin_src emacs-lisp :tangle ~/.config/doom/config.el
(setq org-default-notes-file (concat org-directory "/capture.org"))
(map! :leader "x" #'org-capture)
#+end_src

** nyx colorscheme
#+begin_src emacs-lisp :tangle ~/.config/doom/themes/nyx-theme.el :mkdirp yes
(require 'doom-themes)

(defgroup nyx-theme nil
  "Options for doom-themes"
  :group 'doom-themes)

(def-doom-theme nyx
  "A dark theme inspired by the moon"

  ;; name        default   256       16
  ((bg         '("#18131A" nil       nil            ))
   (bg-alt     '("#18131A" nil       nil            ))
   (base0      '("#261e29" "#261e29" "black"        ))
   (base1      '("#2f2633" "#2f2633" "brightblack"  ))
   (base2      '("#5e4b66" "#5e4b66" "brightblack"  ))
   (base3      '("#745f7d" "#745f7d" "brightblack"  ))
   (base4      '("#8b7694" "#8b7694" "brightblack"  ))
   (base5      '("#9483a8" "#9483a8" "brightblack"  ))
   (base6      '("#ae9fc9" "#ae9fc9" "brightblack"  ))
   (base7      '("#b0bae3" "#b0bae3" "brightblack"  ))
   (base8      '("#c0caf5" "#c0caf5" "white"        ))
   (fg         '("#a9b1d6" "#a9b1d6" "white"        ))
   (fg-alt     '("#c0caf5" "#c0caf5" "brightwhite"  ))

   (grey       '("#8189af" "#8189af" "brightblack"  ))
   (red        '("#f7768e" "#f7768e" "red"          ))
   (orange     '("#ff9e64" "#ff9e64" "brightred"    ))
   (green      '("#73daca" "#73daca" "green"        ))
   (teal       '("#2ac3de" "#2ac3de" "brightgreen"  ))
   (yellow     '("#e0af68" "#e0af68" "yellow"       ))
   (blue       '("#7aa2f7" "#7aa2f7" "brightblue"   ))
   (dark-blue  '("#565f89" "#565f89" "blue"         ))
   (magenta    '("#bb9af7" "#bb9af7" "magenta"      ))
   (violet     '("#9aa5ce" "#9aa5ce" "brightmagenta"))
   (cyan       '("#b4f9f8" "#b4f9f8" "brightcyan"   ))
   (dark-cyan  '("#7dcfff" "#7dcfff" "cyan"         ))

   (highlight      cyan)
   (vertical-bar   base2)
   (selection      dark-blue)
   (builtin        magenta)
   (comments       base4)
   (doc-comments   (doom-lighten comments 0.2))
   (constants      violet)
   (functions      green)
   (keywords       blue)
   (methods        cyan)
   (operators      blue)
   (type           red)
   (strings        yellow)
   (variables      magenta)
   (numbers        magenta)
   (region         (doom-darken magenta 0.8))
   (error          red)
   (warning        yellow)
   (success        green)
   (vc-modified    orange)
   (vc-added       green)
   (vc-deleted     red)

   (modeline-fg     fg)
   (modeline-fg-alt (doom-blend violet base4 0.2))

   (modeline-bg (doom-darken bg-alt 0.2))
   (modeline-bg-l base2)
   (modeline-bg-inactive (doom-darken bg 0.1))
   (modeline-bg-inactive-l `(,(doom-darken (car bg-alt) 0.05) ,@(cdr base1))))

  ((font-lock-comment-face
    :foreground comments
    :weight 'regular)
   (font-lock-doc-face
    :inherit 'font-lock-comment-face
    :foreground doc-comments
    :weight 'regular)

   ((line-number &override) :foreground base4)
   ((line-number-current-line &override) :foreground cyan)

   (doom-modeline-bar :background highlight)
   (doom-modeline-project-dir :foreground violet :weight 'bold)
   (doom-modeline-buffer-file :weight 'regular)

   (mode-line :background modeline-bg :foreground modeline-fg)
   (mode-line-inactive :background modeline-bg-inactive :foreground modeline-fg-alt)
   (mode-line-emphasis :foreground highlight)

   (magit-blame-heading :foreground orange :background bg-alt)
   (magit-diff-removed :foreground (doom-darken red 0.2) :background (doom-blend red bg 0.1))
   (magit-diff-removed-highlight :foreground red :background (doom-blend red bg 0.2) :bold bold)

   (evil-ex-lazy-highlight :background base2)

   (css-proprietary-property :foreground orange)
   (css-property             :foreground green)
   (css-selector             :foreground blue)

   (markdown-markup-face     :foreground base5)
   (markdown-header-face     :inherit 'bold :foreground red)
   (markdown-code-face       :background base1)
   (mmm-default-submode-face :background base1)

   (org-block            :background (doom-darken bg-alt 0.2))
   (org-level-1          :foreground base8 :weight 'bold :height 1.25)
   (org-level-2          :foreground base7 :weight 'bold :height 1.1)
   (org-level-3          :foreground base6 :bold bold :height 1.0)
   (org-level-4          :foreground base5 :bold bold :height 1.0)
   (org-ellipsis         :underline nil :background bg-alt     :foreground grey)
   (org-quote            :background base1)
   (org-checkbox-statistics-done :foreground base2 :weight 'normal)
   (org-done nil)
   (org-done :foreground green :weight 'normal)
   (org-headline-done :foreground base3 :weight 'normal :strike-through t)
   (org-date :foreground orange)
   (org-code :foreground dark-blue)
   (org-special-keyword :foreground base8 :underline t)
   (org-document-title :foreground base8 :weight 'bold :height 1.5)
   (org-document-info-keyword :foreground base4 :height 0.75)
   (org-block-begin-line :foreground base4 :height 0.8)
   (org-meta-line :foreground base4 :height 0.65)
   (org-list-dt :foreground magenta)

   (org-todo-keyword-faces
    '(("TODO" :foreground base6 :weight normal :underline t)
      ("WAITING" :foreground magenta :weight normal :underline t)
      ("INPROGRESS" :foreground blue :weight normal :underline t)
      ("DONE" :foreground green :weight normal :underline t)
      ("CANCELLED" :foreground red :weight normal :underline t)))

   (org-priority-faces '((65 :foreground orange)
                         (66 :foreground yellow)
                         (67 :foreground cyan)))

   (helm-candidate-number :background blue :foreground bg)

   (web-mode-current-element-highlight-face :background dark-blue :foreground bg)

   (wgrep-face :background base1)

   (ediff-current-diff-A        :foreground red   :background (doom-lighten red 0.8))
   (ediff-current-diff-B        :foreground green :background (doom-lighten green 0.8))
   (ediff-current-diff-C        :foreground blue  :background (doom-lighten blue 0.8))
   (ediff-current-diff-Ancestor :foreground teal  :background (doom-lighten teal 0.8))

   (tooltip :background base1 :foreground fg)

   (ivy-posframe :background base0)

   (lsp-ui-doc-background      :background base0)
   (lsp-face-highlight-read    :background (doom-blend red bg 0.3))
   (lsp-face-highlight-textual :inherit 'lsp-face-highlight-read)
   (lsp-face-highlight-write   :inherit 'lsp-face-highlight-read)
 ))
#+end_src
